# 说说你对前端工程化的理解  
 前端工程化是指将前端开发中的设计、开发、测试和部署等环节进行标准化和自动化，以提高开发效率和代码质量，并降低维护成本。  
  
具体而言，前端工程化包括以下方面：  
  
1. 模块化：使用模块化思想可以将复杂的代码拆分成小的可重用的模块，并且使得不同模块之间的依赖关系更加清晰。  
  
2. 自动化构建：通过使用构建工具（如 Gulp、Webpack、Rollup 等），可以自动化地完成代码编译、压缩、打包、转换、优化等任务，从而提高开发效率。  
  
3. 自动化测试：通过使用自动化测试框架和工具（如 Jest、Mocha、Chai、Selenium 等），可以自动化地完成单元测试、集成测试、UI 测试等任务，从而提高代码质量并减少故障。  
  
4. 自动化部署：通过使用自动化部署工具（如 Jenkins、Travis CI、GitLab CI/CD 等），可以自动化地完成代码上传、服务器部署、数据库更新等任务，从而减少手动操作产生的错误和漏洞。  
  
5. 规范化管理：通过使用代码规范（如 ESLint、Stylelint、Prettier 等）和版本控制系统（如 Git），可以规范开发流程和代码风格，提高代码可读性和可维护性。  
  
前端工程化是将前端开发中的设计、开发、测试和部署等环节进行标准化和自动化，以提高开发效率和代码质量，并降低维护成本。  
  
它是一种现代化的开发方式，适用于各种大小项目的开发，并且可以在不断变化的技术环境中保持竞争力。  
# 说说你对 SSG 的理解  
SSG（Static Site Generation，静态网站生成）是指在构建时预先生成静态页面，并将这些页面部署到 CDN 或者其他存储服务中，以提升 Web 应用的性能和用户体验。  
  
具体来说，SSG 的实现方式通常包括以下几个步骤：  
  
1. 在开发阶段，使用模板引擎等技术创建静态页面模板；  
2. 将需要展示的数据从后台 API 中获取或者通过其他渠道获取，并将其填充到静态页面模板中，生成完整的 HTML 页面；  
3. 使用构建工具（例如 Gatsby、Next.js 等）对静态页面进行构建，生成静态 HTML、CSS 和 JavaScript 文件；  
4. 部署生成好的静态文件到服务器或者 CDN 上，以供用户访问。  
  
相比于传统的动态网页，SSG 具有如下优势：  
  
1. 加载速度快：由于不需要每次请求都动态地渲染页面，SSG 可以减少页面加载时间，从而提高用户体验和搜索引擎排名；  
2. 安全性高：由于没有后台代码和数据库，SSG 不容易受到 SQL 注入等攻击；  
3. 成本低：由于不需要动态服务器等设备，SSG 可以降低网站的运维成本和服务器负担。  
  
需要注意的是，SSG 不适用于频繁更新的内容和动态交互等场景，但对于内容较为稳定和更新较少的网站则是一个性能优化的好选择。  
# 聊聊 vite 和 webpack 的区别  
Vite 和 Webpack 都是前端打包工具，它们的作用类似，但实现方式和使用方法有所不同。以下是它们之间的一些区别：  
  
1. **构建速度**：Vite 的构建速度比 Webpack 更快，因为 Vite 在开发环境下使用了浏览器原生的 ES 模块加载，而不是像 Webpack 一样使用打包后的文件进行模块加载。在 Vite 中，每个模块都可以独立地进行编译和缓存，这意味着它只需要重新编译修改过的模块，而不是整个应用程序。这使得 Vite 开发起来更加高效。  
  
2. **配置复杂度**：Vite 的配置相对更简单，因为它无需进行大量的配置，只需指定一些基本的选项就可以开始开发。Webpack 的配置更加复杂，需要针对具体项目进行不同的配置，且需要理解各种插件、Loader 等概念。  
  
3. **生态环境**：Webpack 的生态环境更加成熟，在社区中拥有广泛的支持和丰富的插件库。而 Vite 尚处于发展阶段，尽管其已经获得了很多关注，但其生态系统仍然不太完善。  
  
4. **功能特性**：Webpack 是一个功能更加全面的打包工具，支持各种 Loader 和插件，可以处理多种类型的文件和资源。而 Vite 的设计初衷是专注于开发环境下的快速构建，因此其对一些高级特性的支持相对较少。  
  
综上所述，Vite 更适合用于开发环境下的快速构建，而 Webpack 则更适合用于生产环境下的复杂应用程序的打包处理。选择使用哪种工具需要根据具体项目需求进行评估。  
# 你对 babel 了解吗，能不能说说几个 stage 代表什么意思？  
stage-x：指处于某一阶段的js语言提案。  
  
`stage-0、stage-1、stage-2、stage-3、stage-4` 分别对应的就是进入标准之前的5个阶段，不同 `stage-x` 之间存在依赖关系，数字越小，阶段越靠后，靠后阶段包含前面阶段所有的功能，简单理解就是stage-0包含stage-1/2/3的内容，所以如果你不知道需要哪个stage-x的话，直接引入 `stage-0` 就好了。  
  
* Stage 0 - 设想（Strawman）：只是一个想法，可能有 Babel 插件。  
* Stage 1 - 建议（Proposal）：这是值得跟进的。  
* Stage 2 - 草案（Draft）：初始规范。  
* Stage 3 - 候选（Candidate）：完成规范并在浏览器上初步实现。  
* Stage 4 - 完成（Finished）：将添加到下一个年度版本发布中。  
# 什么是 CI/CD？  
* `CI`，Continuous Integration，持续集成。  
* `CD`，Continuous Deployment，持续部署。  
  
`CICD` 一般合称，无需特意区分二者区别。从开发、测试到上线的过程中，借助于 CICD 进行一些自动化处理，保障项目质量。  
  
`CICD` 与 git 集成在一起，可理解为服务器端的 `git hooks`: 当代码 push 到远程仓库后，借助 `WebHooks` 对当前代码在构建服务器(即 CI 服务器，也称作 Runner)中进行自动构建、测试及部署等。  
  
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e1576bdb44b42b096e4aa5e9ec2fc81~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)  
  
它有若干好处:  
  
1. 功能分支提交后，通过 CICD 进行自动化测试、语法检查等，**如未通过 CICD，则无法 CodeReview，更无法合并到生产环境分支进行上线**  
2. 功能分支提交后，通过 CICD 检查 npm 库的风险、检查构建镜像容器的风险等  
3. 功能分支提交后，通过 CICD 对当前分支代码构建独立镜像并生成独立的分支环境地址进行测试，**如对每一个功能分支生成一个可供测试的地址，一般是 `<branch>.dev.shanyue.tech` 此种地址**  
4. 功能分支测试通过后，合并到主分支，自动构建镜像并部署到生成环境 (一般生成环境需要手动触发、自动部署)  
  
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bc88ef327f54e518d8107e9b698520f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)  
  
由于近些年来 CICD 的全面介入，项目开发的工作流就是 CICD 的工作流，请看一个比较完善的 CICD Workflow。  
  
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4746a6b8c41439d9f73ddbfb231d5f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image)  
  
## CICD 工具  
  
`CICD` 集成于 CICD 工具及代码托管服务。CICD 有时也可理解为进行 CICD 的构建服务器，而提供 CICD 的服务，如以下产品，将会提供构建服务与 github/gitlab 集成在一起。  
  
* `jenkins`  
* `Travis CI`  
  
如果你们公司没有 CICD 基础设置，那么你可以尝试 github 免费的 CICD 服务: [github actions](https://github.com/features/actions)。  
  
如果以 `gitlab CI` 作为 CICD 工具，此时需要自建 `gitlab Runner` 作为构建服务器。  
  
## 一段简单的 CICD 配置  
  
每一家 CICD 产品，都有各自的配置方式，但是总体上用法差不多。以下 CI 脚本指当在 master 有代码变更时，自动部署上线。  
  
```yaml  
deploy:  
  stage: deploy  
  only:  
    - master  
  script:  
    - docker build -t harbor.shanyue.tech/fe/devtools-app  
    - docker push harbor.shanyue.tech/fe/devtools-app  
    - helm upgrade -install devtools-app-chart .  
```  
# 说说 webpack-dev-server 的原理  
## 简介  
在看`webpack-dev-server`源码之前，我们要先弄明白`webpack-dev-server`是个什么，它能做哪些事情。  
  
我们知道用`webpack`可以打包我们的项目文件，然后部署上线，但是在开发过程中，我们想实时看到代码变更后我们的项目效果时，我们就会启动一个服务来监听代码文件变化，并将新的变更及时的展现在我们的浏览器上，极大的提高了我们的开发效率，这就是`webpack-dev-server`带给我们的东西。  
  
### 版本  
- webpack-dev-server：4.7.4  
  
## 📢注意  
为了方便阅读文章里使用的代码都是精简后主要流程的伪代码。  
  
## 流程图  
为了便于串联起来理解，整理了一份主要步骤的流程图  
  
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d68c6c91ba09413fa225c518f0851057~tplv-k3u1fbpfcp-watermark.image?)  
  
## 命令行启动  
当我们在命令行敲下`npm run start`，一般后面都是运行：  
```  
"start": "webpack serve --open",  
```  
这里`webpack`就会基于我们`webpack.config.js`里的配置创建一个`compiler`，然后基于`compiler`和`devServer`相关配置生成一个`WepackDevServer`实例，该实例会启动一个`express`服务来帮我们监听静态资源变化并更新。  
我们以下面这段代码为例开始我们的源码探索：  
```js  
"use strict";  
  
const Webpack = require("webpack");  
const WebpackDevServer = require("../../../lib/Server");  
const webpackConfig = require("./webpack.config");  
  
const compiler = Webpack(webpackConfig);  
const devServerOptions = { ...webpackConfig.devServer, open: true };  
const server = new WebpackDevServer(devServerOptions, compiler);  
  
const runServer = async () => {  
  console.log("Starting server...");  
  await server.start();  
};  
  
runServer();  
```  
因为我们是在研究`wepack-dev-server`，这里我们主要关注`server.start()`方法里发生了什么。  
  
## start  
  
```js  
  async start() {  
    // 这里主要是对我们的配置进行校验和补充（没配置的加默认项）  
    await this.normalizeOptions();  
    // 配置devserver服务的域名和端口  
    this.options.host = await Server.getHostname(this.options.host);  
    this.options.port = await Server.getFreePort(this.options.port);  
    // 初始化client和dev-server，以plugin的形式挂到compiler上，添加hooks插件，实例化express服务等  
    await this.initialize();  
  
    const listenOptions = { host: this.options.host, port: this.options.port };  
    // 启动express服务  
    await (  
      new Promise((resolve) => {  
        (this.server).listen(listenOptions, () => {  
          resolve();  
        });  
      })  
    );  
    // websocket长连接  
    if (this.options.webSocketServer) {  
      this.createWebSocketServer();  
    }  
  
    this.logStatus();  
  
    if (typeof this.options.onListening === "function") {  
      this.options.onListening(this);  
    }  
  }  
```  
  
### 初始化  
上面的`await this.initialize();`这里做了很多事情，来详细看下：  
```js  
// 1. 加载client和dev-server文件，以plugin的形式挂到compiler上  
additionalEntries.push(  
        `${require.resolve("../client/index.js")}?${webSocketURLStr}`  
      );  
   
if (this.options.hot === "only") {  
  additionalEntries.push(require.resolve("webpack/hot/only-dev-server"));  
} else if (this.options.hot) {  
  additionalEntries.push(require.resolve("webpack/hot/dev-server"));  
}  
  
if (typeof webpack.EntryPlugin !== "undefined") {  
  for (const additionalEntry of additionalEntries) {  
    new webpack.EntryPlugin(compiler.context, additionalEntry, {  
      // eslint-disable-next-line no-undefined  
      name: undefined,  
    }).apply(compiler);  
  }  
}  
// 2. 挂载模块热替换插件  
const plugin = new webpack.HotModuleReplacementPlugin();  
plugin.apply(compiler);  
              
// 这里主要是在webpack编译完成的done钩子函数中进行消息广播给客户端  
this.setupHooks();  
// 创建一个express实例  
this.setupApp();  
// 给express实例添加请求头header检测  
this.setupHostHeaderCheck();  
// dev中间件，修改webpack打包输出方式，在webpack不同钩子注册回调，启动webpack编译代码，从内存中读取数据流等  
this.setupDevMiddleware();  
// 处理客户端请求  
this.setupBuiltInRoutes();  
// 监听文件变化  
this.setupWatchFiles();  
// 监听静态文件变化  
this.setupWatchStaticFiles();  
// 根据用户配置添加一些中间件，比如：代理  
this.setupMiddlewares();  
// 基于express实例创建服务  
this.createServer();  
```  
  
#### setupHooks  
`setupHooks`主要做的就是在`webpack`的`done`钩子上挂了个给客户端广播消息的回调，通过这个回调，客户端就能知道项目工程代码有更新，这时候客户端就会发请求给`express`服务去获取最新的`webpack`打包的代码。  
```js  
this.compiler.hooks.done.tap(  
  "webpack-dev-server",  
  (stats) => {  
    if (this.webSocketServer) {  
      // 给客户端发消息，包括更新类型，状态，hash等  
      this.sendStats(this.webSocketServer.clients, this.getStats(stats));  
    }  
    this.stats = stats;  
  }  
);  
```  
  
#### setupDevMiddleware  
`setupDevMiddleware` 函数返回结果是 express 标准的 middleware 用于处理浏览器静态资源的请求。执行过程中显示初始化了一个 `context` 对象，默认非 `lazy` 模式，开启了` webpack` 的 `watch` 模式开始启动编译。  
  
然后将 `compiler` 的原来基于 `fs` 模块的 `outputFileSystem` 替换成 `memory-fs`模块的实例。`memory-fs` 是实现了 `node`的 `fs api` 的基于内存的 `fileSystem`，这意味着 `webpack` 编译后的资源不会被输出到硬盘而是内存。最后将真正处理请求的 `middleware` 返回装载在` express` 上。  
```js  
// 启动webpack编译代码  
context.compiler.watch(watchOptions, errorHandler);  
  
// 将webpack打包文件改成写入内存  
outputFileSystem = memfs.createFsFromVolume(new memfs.Volume());  
  
// 不同钩子注册回调  
context.compiler.hooks.watchRun.tap("webpack-dev-middleware", invalid);  
context.compiler.hooks.invalid.tap("webpack-dev-middleware", invalid);  
context.compiler.hooks.done.tap("webpack-dev-middleware", done);  
  
```  
  
## 更新  
上面就是`npm run start`把项目跑起来经历的过程，接下来就是我们对项目代码进行开发后实现视图更新了。  
  
因为`webpack-dev-server`使用的是`webpack`的`watch`模式进行的编译，当我们更新了代码后，`webpack`是能够监听到代码变化的，代码变化后，`webpack`会再次将我们的项目代码进行打包编译，编译完成后，就会触发`done`钩子函数了。  
  
在上面初始化的时候，我们是在`done`钩子上挂载了回调的。  
  
1. 是上面`setupHooks`里的`websocketServer`对客户端进行消息广播，通知客户端项目代码有更新了。  
```js  
this.compiler.hooks.done.tap(  
  "webpack-dev-server",  
  (stats) => {  
    if (this.webSocketServer) {  
      // 给客户端发消息，包括更新类型，状态，hash等  
      this.sendStats(this.webSocketServer.clients, this.getStats(stats));  
    }  
    this.stats = stats;  
  }  
);  
```  
  
2. 当客户端接收到`websocket`广播的消息后，会触发`reloadApp`方法（`webpack`打包时注入进去的），`reloadApp`会根据广播消息里的更新类型选择是页面更新`liveReload`还是模块更新`hotReload`。  
  
3. 在客户端更新页面时，会去请求类似`c390bbe0037a0dd079a6.hot-update.json`，`main.c390bbe0037a0dd079a6.hot-update.js`这样的两个文件，这两个文件是`webpack` 使用了 `HotModuleReplacementPlugin` 编译时，每次增量编译就会多产出的两个文件， 分别是描述 `chunk` 更新的 `manifest`文件和更新过后的 `chunk` 文件。  
  
4. 拿到这两个增量文件后，再去请求`express`服务器去获取最新编译打包的`bundle.js`。  
  
5. 根据更新类型，选择是两个增量文件和`bundle.js`比对局部更新还是页面更新。  
  
  
  
  
  
  
  
  
  
  
  
  
# webpack loader 和 plugin 实现原理  
本文讨论的核心内容如下：  
  
1. `webpack`进行打包的基本原理  
2. 如何自己实现一个`loader`和`plugin`  
  
注： 本文使用的`webpack`版本是`v4.43.0`, `webpack-cli`版本是`v3.3.11`，`node`版本是`v12.14.1`，`npm`版本`v6.13.4`(如果你喜欢`yarn`也是可以的)，演示用的`chrome`浏览器版本`81.0.4044.129（正式版本） （64 位）`  
  
# 1\. webpack打包基本原理  
  
webpack的一个核心功能就是把我们写的模块化的代码，打包之后，生成可以在浏览器中运行的代码，我们这里也是从简单开始，一步步探索webpack的打包原理  
  
## 1.1 一个简单的需求  
  
我们首先建立一个空的项目，使用`npm init -y`快速初始化一个`package.json`，然后安装`webpack webpack-cli`  
  
接下来，在根目录下创建`src`目录，`src`目录下创建`index.js`，`add.js`，`minus.js`，根目录下创建`index.html`，其中`index.html`引入`index.js`，在`index.js`引入`add.js`，`minus.js`，  
  
目录结构如下：  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d9fbcada8b2c8~tplv-t2oaga2asx-image.image)  
  
文件内容如下：  
  
```  
// add.js  
export default (a, b) => {  
    return a + b  
}  
// minus.js  
export const minus = (a, b) => {  
    return a - b  
}  
// index.js  
import add from './add.js'  
import { minus } from './minus.js'  
  
const sum = add(1, 2)  
const division = minus(2, 1)  
console.log('sum>>>>>', sum)  
console.log('division>>>>>', division)  
  
```  
  
```  
<!--index.html-->  
<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>demo</title>  
</head>  
<body>  
    <script src="./src/index.js"></script>  
</body>  
</html>  
  
```  
  
这样直接在`index.html`引入`index.js`的代码，在浏览器中显然是不能运行的，你会看到这样的错误  
  
```  
Uncaught SyntaxError: Cannot use import statement outside a module  
  
```  
  
是的，我们不能在`script`引入的`js`文件里，使用`es6`模块化语法  
  
## 1.2 实现webpack打包核心功能  
  
我们首先在项目根目录下再建立一个bundle.js，这个文件用来对我们刚刚写的模块化`js`代码文件进行打包  
  
我们首先来看webpack官网对于其打包流程的描述：  
  
`it internally builds a dependency graph which maps every module your project needs and generates one or more bundles（webpack会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle）`  
  
在正式开始之前，结合上面`webpack`官网说明进行分析，明确我们进行打包工作的基本流程如下：  
  
1. 首先，我们需要读到入口文件里的内容（也就是index.js的内容）  
2. 其次，分析入口文件，递归的去读取模块所依赖的文件内容，生成依赖图  
3. 最后，根据依赖图，生成浏览器能够运行的最终代码  
  
### 1\. 处理单个模块（以入口为例）  
  
#### 1.1 获取模块内容  
  
既然要读取文件内容，我们需要用到`node.js`的核心模块`fs`，我们首先来看读到的内容是什么：  
  
```  
// bundle.js  
const fs = require('fs')  
const getModuleInfo = file => {  
    const body = fs.readFileSync(file, 'utf-8')  
    console.log(body)  
}  
getModuleInfo('./src/index.js')  
  
```  
  
我们定义了一个方法`getModuleInfo`，这个方法里我们读出文件内容，打印出来，输出的结果如下图：  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d98e51b90bdf8~tplv-t2oaga2asx-image.image)  
  
我们可以看到，入口文件`index.js`的所有内容都以字符串形式输出了，我们接下来可以用正则表达式或者其它一些方法，从中提取到`import`以及`export`的内容以及相应的路径文件名，来对入口文件内容进行分析，获取有用的信息。但是如果`import`和`export`的内容非常多，这会是一个很麻烦的过程，这里我们借助`babel`提供的功能，来完成入口文件的分析   
  
#### 1.2 分析模块内容  
  
我们安装`@babel/parser`，演示时安装的版本号为`^7.9.6`  
  
这个babel模块的作用，就是把我们js文件的代码内容，转换成js对象的形式，这种形式的js对象，称做`抽象语法树(Abstract Syntax Tree, 以下简称AST)`  
  
```  
// bundle.js  
const fs = require('fs')  
const parser = require('@babel/parser')  
const getModuleInfo = file => {  
    const body = fs.readFileSync(file, 'utf-8')  
    const ast = parser.parse(body, {  
        // 表示我们要解析的是es6模块  
       sourceType: 'module'   
    })  
    console.log(ast)  
    console.log(ast.program.body)  
}  
getModuleInfo('./src/index.js')  
  
```  
  
使用`@babel/parser`的`parse`方法把入口文件转化称为了`AST`，我们打印出了`ast`，注意文件内容是在`ast.program.body`中，如下图所示：  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d98ade5426518~tplv-t2oaga2asx-image.image)  
  
入口文件内容被放到一个数组中，总共有六个`Node`节点，我们可以看到，每个节点有一个`type`属性，其中前两个的`type`属性是`ImportDeclaration`，这对应了我们入口文件的两条`import`语句，并且，每一个`type`属性是`ImportDeclaration`的节点，其`source.value`属性是引入这个模块的相对路径，这样我们就得到了入口文件中对打包有用的重要信息了。   
  
接下来要对得到的ast做处理，返回一份结构化的数据，方便后续使用。  
  
#### 1.3 对模块内容做处理  
  
对`ast.program.body`部分数据的获取和处理，本质上就是对这个数组的遍历，在循环中做数据处理，这里同样引入一个babel的模块`@babel/traverse`来完成这项工作。  
  
安装`@babel/traverse`，演示时安装的版本号为`^7.9.6`  
  
```  
const fs = require('fs')  
const path = require('path')  
const parser = require('@babel/parser')  
const traverse = require('@babel/traverse').default  
  
const getModuleInfo = file => {  
    const body = fs.readFileSync(file, 'utf-8')  
    const ast = parser.parse(body, {  
       sourceType: 'module'   
    })  
    const deps = {}  
    traverse(ast, {  
        ImportDeclaration({ node }) {  
            const dirname = path.dirname(file);  
            const absPath = './' + path.join(dirname, node.source.value)  
            deps[node.source.value] = absPath  
        }  
    })  
    console.log(deps)  
}  
getModuleInfo('./src/index.js')  
  
```  
  
创建一个对象`deps`，用来收集模块自身引入的依赖，使用`traverse`遍历`ast`，我们只需要对`ImportDeclaration`的节点做处理，注意我们做的处理实际上就是把相对路径转化为绝对路径，这里我使用的是`Mac`系统，如果是`windows`系统,注意斜杠的区别  
  
获取依赖之后，我们需要对`ast`做语法转换，把`es6`的语法转化为`es5`的语法，使用`babel`核心模块`@babel/core`以及`@babel/preset-env`完成  
  
安装`@babel/core @babel/preset-env`，演示时安装的版本号均为`^7.9.6`  
  
```  
const fs = require('fs')  
const path = require('path')  
const parser = require('@babel/parser')  
const traverse = require('@babel/traverse').default  
const babel = require('@babel/core')  
  
const getModuleInfo = file => {  
    const body = fs.readFileSync(file, 'utf-8')  
    const ast = parser.parse(body, {  
       sourceType: 'module'   
    })  
    const deps = {}  
    traverse(ast, {  
        ImportDeclaration({ node }) {  
            const dirname = path.dirname(file);  
            const absPath = './' + path.join(dirname, node.source.value)  
            deps[node.source.value] = absPath  
        }  
    })  
    const { code } = babel.transformFromAst(ast, null, {  
        presets: ["@babel/preset-env"]  
    })  
    const moduleInfo = { file, deps, code }  
    console.log(moduleInfo)  
    return moduleInfo  
}  
getModuleInfo('./src/index.js')  
  
```  
  
如下图所示，我们最终把一个模块的代码，转化为一个对象形式的信息，这个对象包含文件的绝对路径，文件所依赖模块的信息，以及模块内部经过`babel`转化后的代码  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d93fe0ee65d14~tplv-t2oaga2asx-image.image)  
  
### 2\. 递归的获取所有模块的信息  
  
这个过程，也就是获取`依赖图(dependency graph)`的过程，这个过程就是从入口模块开始，对每个模块以及模块的依赖模块都调用`getModuleInfo`方法就行分析，最终返回一个包含所有模块信息的对象  
  
```  
const parseModules = file => {  
    // 定义依赖图  
    const depsGraph = {}  
    // 首先获取入口的信息  
    const entry = getModuleInfo(file)  
    const temp = [entry]  
    for (let i = 0; i < temp.length; i++) {  
        const item = temp[i]  
        const deps = item.deps  
        if (deps) {  
            // 遍历模块的依赖，递归获取模块信息  
            for (const key in deps) {  
                if (deps.hasOwnProperty(key)) {  
                    temp.push(getModuleInfo(deps[key]))  
                }  
            }  
        }  
    }  
    temp.forEach(moduleInfo => {  
        depsGraph[moduleInfo.file] = {  
            deps: moduleInfo.deps,  
            code: moduleInfo.code  
        }  
    })  
    console.log(depsGraph)  
    return depsGraph  
}  
parseModules('./src/index.js')  
  
```  
  
获得的depsGraph对象如下图：  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d98ce6221d006~tplv-t2oaga2asx-image.image)  
  
我们最终得到的模块分析数据如上图所示，接下来，我们就要根据这里获得的模块分析数据，来生产最终浏览器运行的代码。  
  
### 3\. 生成最终代码  
  
在我们实现之前，观察上一节最终得到的依赖图，可以看到，最终的code里包含exports以及require这样的语法，所以，我们在生成最终代码时，要对exports和require做一定的实现和处理  
  
我们首先调用之前说的parseModules方法，获得整个应用的依赖图对象：  
  
```  
const bundle = file => {  
    const depsGraph = JSON.stringify(parseModules(file))  
}  
  
```  
  
接下来我们应该把依赖图对象中的内容，转换成能够执行的代码，以字符串形式输出。 我们把整个代码放在自执行函数中，参数是依赖图对象  
  
```  
const bundle = file => {  
    const depsGraph = JSON.stringify(parseModules(file))  
    return `(function(graph){  
        function require(file) {  
            var exports = {};  
            return exports  
        }  
        require('${file}')  
    })(${depsGraph})`  
}  
  
```  
  
接下来内容其实很简单，就是我们取得入口文件的code信息，去执行它就好了，使用eval函数执行，初步写出代码如下：  
  
```  
const bundle = file => {  
    const depsGraph = JSON.stringify(parseModules(file))  
    return `(function(graph){  
        function require(file) {  
            var exports = {};  
            (function(code){  
                eval(code)  
            })(graph[file].code)  
            return exports  
        }  
        require('${file}')  
    })(${depsGraph})`  
}  
  
```  
  
上面的写法是有问题的，我们需要对file做绝对路径转化，否则`graph[file].code`是获取不到的，定义adsRequire方法做相对路径转化为绝对路径  
  
```  
const bundle = file => {  
    const depsGraph = JSON.stringify(parseModules(file))  
    return `(function(graph){  
        function require(file) {  
            var exports = {};  
            function absRequire(relPath){  
                return require(graph[file].deps[relPath])  
            }  
            (function(require, exports, code){  
                eval(code)  
            })(absRequire, exports, graph[file].code)  
            return exports  
        }  
        require('${file}')  
    })(${depsGraph})`  
}  
  
```  
  
接下来，我们只需要执行bundle方法，然后把生成的内容写入一个JavaScript文件即可  
  
```  
const content = bundle('./src/index.js')  
// 写入到dist/bundle.js  
fs.mkdirSync('./dist')  
fs.writeFileSync('./dist/bundle.js', content)  
  
```  
  
最后，我们在index.html引入这个`./dist/bundle.js`文件，我们可以看到控制台正确输出了我们想要的结果  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d98729f5a309a~tplv-t2oaga2asx-image.image)  
  
### 4\. bundle.js的完整代码  
  
```  
const fs = require('fs')  
const path = require('path')  
const parser = require('@babel/parser')  
const traverse = require('@babel/traverse').default  
const babel = require('@babel/core')  
  
const getModuleInfo = file => {  
    const body = fs.readFileSync(file, 'utf-8')  
    console.log(body)  
    const ast = parser.parse(body, {  
       sourceType: 'module'   
    })  
    // console.log(ast.program.body)  
    const deps = {}  
    traverse(ast, {  
        ImportDeclaration({ node }) {  
            const dirname = path.dirname(file);  
            const absPath = './' + path.join(dirname, node.source.value)  
            deps[node.source.value] = absPath  
        }  
    })  
    const { code } = babel.transformFromAst(ast, null, {  
        presets: ["@babel/preset-env"]  
    })  
    const moduleInfo = { file, deps, code }  
    return moduleInfo  
}  
  
const parseModules = file => {  
    // 定义依赖图  
    const depsGraph = {}  
    // 首先获取入口的信息  
    const entry = getModuleInfo(file)  
    const temp = [entry]  
    for (let i = 0; i < temp.length; i++) {  
        const item = temp[i]  
        const deps = item.deps  
        if (deps) {  
            // 遍历模块的依赖，递归获取模块信息  
            for (const key in deps) {  
                if (deps.hasOwnProperty(key)) {  
                    temp.push(getModuleInfo(deps[key]))  
                }  
            }  
        }  
    }  
    temp.forEach(moduleInfo => {  
        depsGraph[moduleInfo.file] = {  
            deps: moduleInfo.deps,  
            code: moduleInfo.code  
        }  
    })  
    // console.log(depsGraph)  
    return depsGraph  
}  
  
  
// 生成最终可以在浏览器运行的代码  
const bundle = file => {  
    const depsGraph = JSON.stringify(parseModules(file))  
    return `(function(graph){  
        function require(file) {  
            var exports = {};  
            function absRequire(relPath){  
                return require(graph[file].deps[relPath])  
            }  
            (function(require, exports, code){  
                eval(code)  
            })(absRequire, exports, graph[file].code)  
            return exports  
        }  
        require('${file}')  
    })(${depsGraph})`  
}  
  
  
const build = file => {  
    const content = bundle(file)  
    // 写入到dist/bundle.js  
    fs.mkdirSync('./dist')  
    fs.writeFileSync('./dist/bundle.js', content)  
}  
  
build('./src/index.js')  
  
```  
  
# 2\. 手写`loader`和`plugin`  
  
## 2.1 如何自己实现一个`loader`  
  
loader本质上就是一个函数，这个函数会在我们在我们加载一些文件时执行  
  
### 2.1.1 如何实现一个同步`loader`  
  
首先我们初始化一个项目，项目结构如图所示：  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d9a1c5aa08dcc~tplv-t2oaga2asx-image.image)  
  
其中index.js和webpack.config.js的文件内容如下：   
  
```  
// index.js  
console.log('我要学好前端，因为学好前端可以： ')  
  
// webpack.config.js  
const path = require('path')  
module.exports = {  
    mode: 'development',  
    entry: {  
        main: './src/index.js'  
    },  
    output: {  
        path: path.resolve(__dirname, 'dist'),  
        filename: '[name].js'  
    }  
}  
  
```  
  
我们在根目录下创建`syncLoader.js`，用来实现一个同步的loader，注意这个函数必须返回一个`buffer`或者`string`  
  
```  
// syncloader.ja  
module.exports = function (source) {  
    console.log('source>>>>', source)  
    return source  
}  
  
```  
  
同时，我们在`webpack.config.js`中使用这个`loader`，我们这里使用`resolveLoader`配置项，指定`loader`查找文件路径，这样我们使用`loader`时候可以直接指定`loader`的名字  
  
```  
const path = require('path')  
module.exports = {  
    mode: 'development',  
    entry: {  
        main: './src/index.js'  
    },  
    output: {  
        path: path.resolve(__dirname, 'dist'),  
        filename: '[name].js'  
    },  
    resolveLoader: {  
        // loader路径查找顺序从左往右  
        modules: ['node_modules', './']  
    },  
    module: {  
        rules: [  
            {  
                test: /\.js$/,  
                use: 'syncLoader'  
            }  
        ]  
    }  
}  
  
```  
  
接下来我们运行打包命令，可以看到命令行输出了source内容，也就是loader作用文件的内容。  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d9af78146f8a0~tplv-t2oaga2asx-image.image)  
  
接着我们改造我们的loader:   
  
```  
module.exports = function (source) {  
    source += '升值加薪'  
    return source  
}  
  
```  
  
我们再次运行打包命令，去观察打包后的代码：  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d9b2306cb5278~tplv-t2oaga2asx-image.image)  
  
这样，我们就实现了一个简单的loader，为我们的文件增加一条信息。 我们可以尝试在`loader`的函数里打印`this`，发现输出结果是非常长的一串内容，`this`上有很多我们可以在`loader`中使用的有用信息，所以，对于`loader`的编写，一定不要使用箭头函数，那样会改变`this`的指向。   
  
一般来说，我们会去使用官方推荐的`loader-utils`包去完成更加复杂的`loader`的编写  
  
我们继续安装`loader-utils`，版本是`^2.0.0`  
  
我们首先改造`webpack.config.js`：  
  
```  
const path = require('path')  
  
module.exports = {  
    mode: 'development',  
    entry: {  
        main: './src/index.js'  
    },  
    output: {  
        path: path.resolve(__dirname, 'dist'),  
        filename: '[name].js'  
    },  
    resolveLoader: {  
        // loader路径查找顺序从左往右  
        modules: ['node_modules', './']  
    },  
    module: {  
        rules: [  
            {  
                test: /\.js$/,  
                use: {  
                    loader: 'syncLoader',  
                    options: {  
                        message: '升值加薪'  
                    }  
                }  
            }  
        ]  
    }  
}  
  
```  
  
注意到，我们为我们的`loader`增加了`options`配置项，接下来在loader函数里使用loader-utils获取配置项内容，拼接内容，我们依然可以得到与之前一样的打包结果  
  
```  
// syncLoader.js  
const loaderUtils = require('loader-utils')  
module.exports = function (source) {  
    const options = loaderUtils.getOptions(this)  
    console.log(options)  
    source += options.message  
    // 可以传递更详细的信息  
    this.callback(null, source)  
}  
  
```  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d9c109f578ef6~tplv-t2oaga2asx-image.image)  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d9c1afaa94890~tplv-t2oaga2asx-image.image)  
  
这样，我们就完成了一个简单的同步`loader`的编写  
  
### 2.1.2 如何实现一个异步`loader`  
  
和同步loader的编写方式非常相似，我们在根目录下建立一个asyncLoader.js的文件，内容如下：  
  
```  
const loaderUtils = require('loader-utils')  
module.exports = function (source) {  
    const options = loaderUtils.getOptions(this)  
    const asyncfunc = this.async()  
    setTimeout(() => {  
        source += '走上人生颠覆'  
        asyncfunc(null, res)  
    }, 200)  
}  
  
```  
  
注意这里的`this.async()`，用官方的话来说就是`Tells the loader-runner that the loader intends to call back asynchronously. Returns this.callback.`也就是让webpack知道这个loader是异步运行，返回的是和同步使用时一致的`this.callback`  
  
接下来我们修改webpack.config.js  
  
```  
const path = require('path')  
module.exports = {  
    mode: 'development',  
    entry: {  
        main: './src/index.js'  
    },  
    output: {  
        path: path.resolve(__dirname, 'dist'),  
        filename: '[name].js'  
    },  
    resolveLoader: {  
        // loader路径查找顺序从左往右  
        modules: ['node_modules', './']  
    },  
    module: {  
        rules: [  
            {  
                test: /\.js$/,  
                use: [  
                    {  
                        loader: 'syncLoader',  
                        options: {  
                            message: '走上人生巅峰'  
                        }  
                    },  
                    {  
                        loader: 'asyncLoader'  
                    }  
                ]  
            }  
        ]  
    }  
}  
  
```  
  
注意loader执行顺序是从下网上的，所以首先为文本写入‘升值加薪’，然后写入‘走上人生巅峰’  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d9cc0c3a652c9~tplv-t2oaga2asx-image.image)  
  
到此，我们简单介绍了如何手写一个`loader`，在实际项目中，可以考虑一部分公共的简单逻辑，可以通过编写一个`loader`来完成(比如国际化文本替换)  
  
## 2.2 如何自己实现一个`plugin`  
  
`plugin`通常是在`webpack`在打包的某个时间节点做一些操作，我们使用`plugin`的时候，一般都是`new Plugin()`这种形式使用，所以，首先应该明确的是，`plugin`应该是一个类。  
  
我们初始化一个与上一接实现loader时候一样的项目，根目录下创建一个`demo-webpack-plugin.js`的文件，我们首先在`webpack.config.js`中使用它  
  
```  
const path = require('path')  
const DemoWebpackPlugin = require('./demo-webpack-plugin')  
module.exports = {  
    mode: 'development',  
    entry: {  
        main: './src/index.js'  
    },  
    output: {  
        path: path.resolve(__dirname, 'dist'),  
        filename: '[name].js'  
    },  
    plugins: [  
        new DemoWebpackPlugin()  
    ]  
}  
  
```  
  
再来看`demo-webpack-plugin.js`的实现  
  
```  
class DemoWebpackPlugin {  
    constructor () {  
        console.log('plugin init')  
    }  
    apply (compiler) {  
  
    }  
}  
  
module.exports = DemoWebpackPlugin  
  
```  
  
我们在`DemoWebpackPlugin`的构造函数打印一条信息，当我们执行打包命令时，这条信息就会输出，`plugin`类里面需要实现一个`apply`方法，`webpack`打包时候，会调用`plugin`的`aplly`方法来执行`plugin`的逻辑，这个方法接受一个`compiler`作为参数，这个`compiler`是`webpack`实例  
  
plugin的核心在于，apply方法执行时，可以操作webpack本次打包的各个时间节点（hooks，也就是生命周期勾子），在不同的时间节点做一些操作  
  
关于webpack编译过程的各个生命周期勾子，可以参考[Compiler Hooks](https://v4.webpack.js.org/api/compiler-hooks/)  
  
同样，这些hooks也有同步和异步之分，下面演示`compiler hooks`的写法，一些重点内容可以参考注释：  
  
```  
class DemoWebpackPlugin {  
    constructor () {  
        console.log('plugin init')  
    }  
    // compiler是webpack实例  
    apply (compiler) {  
        // 一个新的编译(compilation)创建之后（同步）  
        // compilation代表每一次执行打包，独立的编译  
        compiler.hooks.compile.tap('DemoWebpackPlugin', compilation => {  
            console.log(compilation)  
        })  
        // 生成资源到 output 目录之前（异步）  
        compiler.hooks.emit.tapAsync('DemoWebpackPlugin', (compilation, fn) => {  
            console.log(compilation)  
            compilation.assets['index.md'] = {  
                // 文件内容  
                source: function () {  
                    return 'this is a demo for plugin'  
                },  
                // 文件尺寸  
                size: function () {  
                    return 25  
                }  
            }  
            fn()  
        })  
    }  
}  
  
module.exports = DemoWebpackPlugin  
  
```  
  
我们的这个`plugin`的作用就是，打包时候自动生成一个`md`文档，文档内容是很简单的一句话  
  
上述异步hooks的写法也可以是以下两种：  
  
```  
// 第二种写法(promise)  
compiler.hooks.emit.tapPromise('DemoWebpackPlugin', (compilation) => {  
    return new Promise((resolve, reject) => {  
        setTimeout(() => {  
            resolve()  
        }, 1000)  
    }).then(() => {  
        console.log(compilation.assets)  
        compilation.assets['index.md'] = {  
            // 文件内容  
            source: function () {  
                return 'this is a demo for plugin'  
            },  
            // 文件尺寸  
            size: function () {  
                return 25  
            }  
        }  
    })  
})  
// 第三种写法(async await)  
compiler.hooks.emit.tapPromise('DemoWebpackPlugin', async (compilation) => {  
    await new Promise((resolve, reject) => {  
        setTimeout(() => {  
            resolve()  
        }, 1000)  
    })  
    console.log(compilation.assets)  
    compilation.assets['index.md'] = {  
        // 文件内容  
        source: function () {  
            return 'this is a demo for plugin'  
        },  
        // 文件尺寸  
        size: function () {  
            return 25  
        }  
    }  
})  
  
```  
  
最终的输出结果都是一样的，在每次打包时候生成一个md文档  
  
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171d9f20d45da9c4~tplv-t2oaga2asx-image.image)  
  
# 说下Vite的原理  
# 背景  
这里的背景介绍会从与`Vite`紧密相关的两个概念的发展史说起，一个是`JavaScript`的模块化标准，另一个是前端构建工具。  
  
### 共存的模块化标准  
为什么`JavaScript`会有多种共存的模块化标准？因为js在设计之初并没有模块化的概念，随着前端业务复杂度不断提高，模块化越来越受到开发者的重视，社区开始涌现多种模块化解决方案，它们相互借鉴，也争议不断，形成多个派系，从`CommonJS`开始，到`ES6`正式推出`ES Modules`规范结束，所有争论，终成历史，`ES Modules`也成为前端重要的基础设施。  
  
- **CommonJS**：现主要用于Node.js（Node@13.2.0开始支持直接使用ES Module）  
- **AMD**：`require.js` 依赖前置，市场存量不建议使用  
- **CMD**：`sea.js` 就近执行，市场存量不建议使用  
- **ES Module**：ES语言规范，标准，趋势，未来  
  
对模块化发展史感兴趣的可以看下[《前端模块化开发那点历史》@玉伯](https://github.com/seajs/seajs/issues/588 "《前端模块化开发那点历史》")，而`Vite`的核心正是依靠浏览器对ES Module规范的实现。  
  
### 发展中的构建工具  
  
近些年前端工程化发展迅速，各种构建工具层出不穷，目前`Webpack`仍然占据统治地位，npm 每周下载量达到两千多万次。下面是我按 npm 发版时间线列出的开发者比较熟知的一些构建工具。  
  
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4401a88bf0e04c668e6623d2134c60d7~tplv-k3u1fbpfcp-watermark.image?)  
  
  
### 当前工程化痛点  
  
现在常用的构建工具如`Webpack`，主要是通过抓取-编译-构建整个应用的代码（也就是常说的打包过程），生成一份编译、优化后能良好兼容各个浏览器的的生产环境代码。在开发环境流程也基本相同，需要先将整个应用构建打包后，再把打包后的代码交给`dev server`（开发服务器）。  
  
`Webpack`等构建工具的诞生给前端开发带来了极大的便利，但随着前端业务的复杂化，js代码量呈指数增长，打包构建时间越来越久，`dev server`（开发服务器）性能遇到瓶颈：  
- **缓慢的服务启动：** 大型项目中`dev server`启动时间达到几十秒甚至几分钟。  
  
- **缓慢的HMR热更新：** 即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降，已达到性能瓶颈，无多少优化空间。  
  
**缓慢的开发环境，大大降低了开发者的幸福感，在以上背景下`Vite`应运而生。**  
  
---  
  
# 什么是Vite？  
**基于esbuild与Rollup，依靠浏览器自身ESM编译功能， 实现极致开发体验的新一代构建工具！**  
  
### 概念  
先介绍以下文中会经常提到的一些基础概念：  
- **依赖：** 指开发不会变动的部分(npm包、UI组件库)，esbuild进行预构建。  
- **源码：** 浏览器不能直接执行的非js代码(.jsx、.css、.vue等)，vite只在浏览器请求相关源码的时候进行转换，以提供ESM源码。  
  
### 开发环境  
- 利用浏览器原生的`ES Module`编译能力，省略费时的编译环节，直给浏览器开发环境源码，`dev server`只提供轻量服务。  
- 浏览器执行ESM的`import`时，会向`dev server`发起该模块的`ajax`请求，服务器对源码做简单处理后返回给浏览器。  
- `Vite`中HMR是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块失活，使得无论应用大小如何，HMR 始终能保持快速更新。  
- 使用`esbuild`处理项目依赖，`esbuild`使用go编写，比一般`node.js`编写的编译器快几个数量级。  
  
### 生产环境  
- 集成`Rollup`打包生产环境代码，依赖其成熟稳定的生态与更简洁的插件机制。  
  
### 处理流程对比  
`Webpack`通过先将整个应用打包，再将打包后代码提供给`dev server`，开发者才能开始开发。  
  
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/181a6bfe5e4d4857bd6bed63a573e2b3~tplv-k3u1fbpfcp-watermark.image?)  
  
  
`Vite`直接将源码交给浏览器，实现`dev server`秒开，浏览器显示页面需要相关模块时，再向`dev server`发起请求，服务器简单处理后，将该模块返回给浏览器，实现真正意义的按需加载。  
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e00801ede5b84abd9bdaadb720d63e53~tplv-k3u1fbpfcp-watermark.image?)  
  
---  
# 基本用法  
### 创建vite项目  
```shell  
$ npm create vite@latest  
```  
### 选取模板  
`Vite` 内置6种常用模板与对应的TS版本，可满足前端大部分开发场景，可以点击下列表格中模板直接在 [StackBlitz](https://vite.new/ "StackBlitz") 中在线试用，还有其他更多的 [社区维护模板](https://github.com/vitejs/awesome-vite#templates "社区维护模板")可以使用。  
|JavaScript                          | TypeScript                                |  
| ----------------------------------- | ----------------------------------------- |  
| [vanilla](https://vite.new/vanilla) | [vanilla-ts](https://vite.new/vanilla-ts) |  
| [vue](https://vite.new/vue)         | [vue-ts](https://vite.new/vue-ts)         |  
| [react](https://vite.new/react)     | [react-ts](https://vite.new/react-ts)     |  
| [preact](https://vite.new/preact)   | [preact-ts](https://vite.new/preact-ts)   |  
| [lit](https://vite.new/lit)         | [lit-ts](https://vite.new/lit-ts)         |  
| [svelte](https://vite.new/svelte)   | [svelte-ts](https://vite.new/svelte-ts)|  
  
### 启动  
```json  
{  
  "scripts": {  
    "dev": "vite", // 启动开发服务器，别名：`vite dev`，`vite serve`  
    "build": "vite build", // 为生产环境构建产物  
    "preview": "vite preview" // 本地预览生产构建产物  
  }  
}  
```  
---  
# 实现原理  
  
### ESbuild 编译  
`esbuild` 使用go编写，cpu密集下更具性能优势，编译速度更快，以下摘自官网的构建速度对比：     
**浏览器：“开始了吗？”**     
**服务器：“已经结束了。”**     
**开发者：“好快，好喜欢！！”**  
  
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6ab1cbe74ef49a9a601e0db0265453a~tplv-k3u1fbpfcp-watermark.image?)  
  
  
### 依赖预构建  
  
- **模块化兼容：** 如开头背景所写，现仍共存多种模块化标准代码，`Vite`在预构建阶段将依赖中各种其他模块化规范(CommonJS、UMD)转换 成ESM，以提供给浏览器。  
- **性能优化：** npm包中大量的ESM代码，大量的`import`请求，会造成网络拥塞。`Vite`使用`esbuild`，将有大量内部模块的ESM关系转换成单个模块，以减少 `import`模块请求次数。  
  
### 按需加载  
  
- 服务器只在接受到import请求的时候，才会编译对应的文件，将ESM源码返回给浏览器，实现真正的按需加载。  
  
### 缓存  
  
- **HTTP缓存：** 充分利用`http`缓存做优化，依赖（不会变动的代码）部分用max-age,immutable **强缓存**，源码部分用304**协商缓存**，提升页面打开速度。  
- **文件系统缓存：** `Vite`在预构建阶段，将构建后的依赖缓存到`node_modules/.vite` ，相关配置更改时，或手动控制时才会重新构建，以提升预构建速度。  
  
### 重写模块路径  
  
浏览器`import`只能引入相对/绝对路径，而开发代码经常使用`npm`包名直接引入`node_module`中的模块，需要做路径转换后交给浏览器。  
- `es-module-lexer` 扫描 import 语法  
- `magic-string` 重写模块的引入路径  
  
```js  
// 开发代码  
import { createApp } from 'vue'  
  
// 转换后  
import { createApp } from '/node_modules/vue/dist/vue.js'  
```  
  
  
# 源码分析  
与`Webpack-dev-server`类似`Vite`同样使用`WebSocket`与客户端建立连接，实现热更新，源码实现基本可分为两部分，源码位置在:  
  
- `vite/packages/vite/src/client` client（用于客户端）  
- `vite/packages/vite/src/node` server（用于开发服务器）  
  
client 代码会在启动服务时注入到客户端，用于客户端对于`WebSocket`消息的处理（如更新页面某个模块、刷新页面）；server 代码是服务端逻辑，用于处理代码的构建与页面模块的请求。  
  
简单看了下源码（vite@2.7.2），核心功能主要是以下几个方法（以下为源码截取，部分逻辑做了删减）：     
1. 命令行启动服务`npm run dev`后，源码执行`cli.ts`，调用`createServer`方法，创建http服务，监听开发服务器端口。  
  
```js  
// 源码位置 vite/packages/vite/src/node/cli.ts  
const { createServer } = await import('./server')  
try {  
    const server = await createServer({  
        root,  
        base: options.base,  
        ...  
    })  
    if (!server.httpServer) {  
        throw new Error('HTTP server not available')  
    }  
    await server.listen()  
}  
```  
2. `createServer`方法的执行做了很多工作，如整合配置项、创建http服务（早期通过koa创建）、创建`WebSocket`服务、创建源码的文件监听、插件执行、optimize优化等。下面注释中标出。  
  
```js  
// 源码位置 vite/packages/vite/src/node/server/index.ts  
export async function createServer(  
    inlineConfig: InlineConfig = {}  
): Promise<ViteDevServer> {  
    // Vite 配置整合  
    const config = await resolveConfig(inlineConfig, 'serve', 'development')  
    const root = config.root  
    const serverConfig = config.server  
  
    // 创建http服务  
    const httpServer = await resolveHttpServer(serverConfig, middlewares, httpsOptions)  
  
    // 创建ws服务  
    const ws = createWebSocketServer(httpServer, config, httpsOptions)  
  
    // 创建watcher，设置代码文件监听  
    const watcher = chokidar.watch(path.resolve(root), {  
        ignored: [  
            '**/node_modules/**',  
            '**/.git/**',  
            ...(Array.isArray(ignored) ? ignored : [ignored])  
        ],  
        ...watchOptions  
    }) as FSWatcher  
  
    // 创建server对象  
    const server: ViteDevServer = {  
        config,  
        middlewares,  
        httpServer,  
        watcher,  
        ws,  
        moduleGraph,  
        listen,  
        ...  
    }  
  
    // 文件监听变动，websocket向前端通信  
    watcher.on('change', async (file) => {  
        ...  
        handleHMRUpdate()  
    })  
  
    // 非常多的 middleware  
    middlewares.use(...)  
      
    // optimize  
    const runOptimize = async () => {...}  
  
    return server  
}  
```  
3. 使用[chokidar](https://www.npmjs.com/package/chokidar "chokidar")监听文件变化，绑定监听事件。  
  
```js  
// 源码位置 vite/packages/vite/src/node/server/index.ts  
  const watcher = chokidar.watch(path.resolve(root), {  
    ignored: [  
      '**/node_modules/**',  
      '**/.git/**',  
      ...(Array.isArray(ignored) ? ignored : [ignored])  
    ],  
    ignoreInitial: true,  
    ignorePermissionErrors: true,  
    disableGlobbing: true,  
    ...watchOptions  
  }) as FSWatcher  
```  
  
4. 通过 [ws](https://www.npmjs.com/package/ws "ws") 来创建`WebSocket`服务，用于监听到文件变化时触发热更新，向客户端发送消息。  
  
```js  
// 源码位置 vite/packages/vite/src/node/server/ws.ts  
export function createWebSocketServer(...){  
    let wss: WebSocket  
    const hmr = isObject(config.server.hmr) && config.server.hmr  
    const wsServer = (hmr && hmr.server) || server  
  
    if (wsServer) {  
        wss = new WebSocket({ noServer: true })  
        wsServer.on('upgrade', (req, socket, head) => {  
            // 服务就绪  
            if (req.headers['sec-websocket-protocol'] === HMR_HEADER) {  
                wss.handleUpgrade(req, socket as Socket, head, (ws) => {  
                    wss.emit('connection', ws, req)  
                })  
            }  
        })  
    } else {  
        ...  
    }  
    // 服务准备就绪，就能在浏览器控制台看到熟悉的打印 [vite] connected.  
    wss.on('connection', (socket) => {  
        socket.send(JSON.stringify({ type: 'connected' }))  
        ...  
    })  
    // 失败  
    wss.on('error', (e: Error & { code: string }) => {  
        ...  
    })  
    // 返回ws对象  
    return {  
        on: wss.on.bind(wss),  
        off: wss.off.bind(wss),  
        // 向客户端发送信息  
        // 多个客户端同时触发  
        send(payload: HMRPayload) {  
            const stringified = JSON.stringify(payload)  
            wss.clients.forEach((client) => {  
                // readyState 1 means the connection is open  
                client.send(stringified)  
            })  
        }  
    }  
}  
```  
5. 在服务启动时会向浏览器注入代码，用于处理客户端接收到的`WebSocket`消息，如重新发起模块请求、刷新页面。  
  
```js  
//源码位置 vite/packages/vite/src/client/client.ts  
async function handleMessage(payload: HMRPayload) {  
  switch (payload.type) {  
    case 'connected':  
      console.log(`[vite] connected.`)  
      break  
    case 'update':  
      notifyListeners('vite:beforeUpdate', payload)  
      ...  
      break  
    case 'custom': {  
      notifyListeners(payload.event as CustomEventName<any>, payload.data)  
      ...  
      break  
    }  
    case 'full-reload':  
      notifyListeners('vite:beforeFullReload', payload)  
      ...  
      break  
    case 'prune':  
      notifyListeners('vite:beforePrune', payload)  
      ...  
      break  
    case 'error': {  
      notifyListeners('vite:error', payload)  
      ...  
      break  
    }  
    default: {  
      const check: never = payload  
      return check  
    }  
  }  
}  
```  
---  
  
# 优势  
  
- 快！快！非常快！！  
- 高度集成，开箱即用。  
- 基于ESM急速热更新，无需打包编译。  
- 基于`esbuild`的依赖预处理，比`Webpack`等node编写的编译器快几个数量级。  
- 兼容`Rollup`庞大的插件机制，插件开发更简洁。  
- 不与`Vue`绑定，支持`React`等其他框架，独立的构建工具。  
- 内置SSR支持。  
- 天然支持TS。  
  
# 不足  
- `Vue`仍为第一优先支持，量身定做的编译插件，对`React`的支持不如`Vue`强大。  
- 虽然已经推出2.0正式版，已经可以用于正式线上生产，但目前市场上实践少。  
- 生产环境集成`Rollup`打包，与开发环境最终执行的代码不一致。  
---  
# 与 webpack 对比  
由于`Vite`主打的是开发环境的极致体验，生产环境集成`Rollup`，这里的对比主要是`Webpack-dev-server`与`Vite-dev-server`的对比：  
  
- 到目前很长时间以来`Webpack`在前端工程领域占统治地位，`Vite`推出以来备受关注，社区活跃，GitHub star 数量激增，目前达到37.4K  
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13034f21bfc43499756af2ae85cdbbd~tplv-k3u1fbpfcp-zoom-1.image)  
- `Webpack`配置丰富使用极为灵活但上手成本高，`Vite`开箱即用配置高度集成  
- `Webpack`启动服务需打包构建，速度慢，`Vite`免编译可秒开  
- `Webpack`热更新需打包构建，速度慢，`Vite`毫秒响应  
- `Webpack`成熟稳定、资源丰富、大量实践案例，`Vite`实践较少  
- `Vite`使用`esbuild`编译，构建速度比`webpack`快几个数量级  
---  
# 兼容性  
- 默认目标浏览器是在`script`标签上支持原生 ESM 和 原生 ESM 动态导入  
- 可使用官方插件 `@vitejs/plugin-legacy`，转义成传统版本和相对应的`polyfill`  
---  
# 未来探索  
- 传统构建工具性能已到瓶颈，主打开发体验的`Vite`，可能会受到欢迎。  
- 主流浏览器基本支持ESM，ESM将成为主流。  
- `Vite`在`Vue3.0`代替`vue-cli`，作为官方脚手架，会大大提高使用量。  
- `Vite2.0`推出后，已可以在实际项目中使用`Vite`。  
- 如果觉得直接使用`Vite`太冒险，又确实有`dev server`速度慢的问题需要解决，可以尝试用`Vite`单独搭建一套`dev server`  
---  
# 相关资源  
### 官方插件  
除了支持现有的`Rollup`插件系统外，官方提供了四个最关键的插件  
- `@vitejs/plugin-vue` 提供 Vue3 单文件组件支持  
- `@vitejs/plugin-vue-jsx`  提供 Vue3 JSX 支持（专用的 Babel 转换插件）  
- `@vitejs/plugin-react` 提供完整的 React 支持  
- `@vitejs/plugin-legacy` 为打包后的文件提供传统浏览器兼容性支持  
  
  
# webpack treeShaking机制的原理是什么？  
> Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination  
  
## tree shaking如何工作的呢?  
  
虽然 tree shaking 的概念在 1990 就提出了，但直到 ES6 的 ES6-style 模块出现后才真正被利用起来。  
  
在ES6以前，我们可以使用CommonJS引入模块：require()，这种引入是动态的，也意味着我们可以基于条件来导入需要的代码：  
  
```js  
let dynamicModule;  
// 动态导入  
if (condition) {  
  myDynamicModule = require("foo");  
} else {  
  myDynamicModule = require("bar");  
}  
```  
  
但是CommonJS规范无法确定在实际运行前需要或者不需要某些模块，所以CommonJS不适合tree-shaking机制。在 ES6 中，引入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：  
  
```js  
// 不可行，ES6 的import是完全静态的  
if (condition) {  
  myDynamicModule = require("foo");  
} else {  
  myDynamicModule = require("bar");  
}  
```  
  
我们只能通过导入所有的包后再进行条件获取。如下：  
  
```js  
import foo from "foo";  
import bar from "bar";  
  
if (condition) {  
  // foo.xxxx  
} else {  
  // bar.xxx  
}  
```  
  
ES6的import语法可以完美使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码。  
  
看完上面的分析，你可能还是有点懵，这里我简单做下总结：因为tree shaking只能在静态modules下工作。ECMAScript 6 模块加载是静态的,因此整个依赖树可以被静态地推导出解析语法树。所以在 ES6 中使用 tree shaking 是非常容易的。  
  
## tree shaking的原理是什么?  
  
看完上面的分析，相信这里你可以很容易的得出题目的答案了：  
  
* ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块  
* 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码  
  
## common.js 和 es6 中模块引入的区别？  
  
从这道题目我们可以很容易的引申出来另外一道“明星”面试题：common.js 和 es6 中模块引入的区别？  
  
CommonJS 是一种模块规范，最初被应用于 Nodejs，成为 Nodejs 的模块规范。运行在浏览器端的 JavaScript 由于也缺少类似的规范，在 ES6 出来之前，前端也实现了一套相同的模块规范 (例如: AMD)，用来对前端模块进行管理。自 ES6 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 ES6 Module 兼容还不太好，我们平时在 Webpack 中使用的 export 和 import，会经过 Babel 转换为 CommonJS 规范。在使用上的差别主要有：  
  
1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。  
  
2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。  
  
3、CommonJs 是单个值导出，ES6 Module可以导出多个  
  
4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层  
  
5、CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined  
  
  
  
  
  
# 介绍一下 tree shaking 及其工作原理  
> Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination。  
  
## tree shaking如何工作的呢？  
  
虽然 tree shaking 的概念在 1990 就提出了，但直到 ES6 的 `ES6-style` 模块出现后才真正被利用起来。  
  
在ES6以前，我们可以使用CommonJS引入模块：require()，这种引入是动态的，也意味着我们可以基于条件来导入需要的代码：  
  
```javascript  
let dynamicModule;  
// 动态导入  
if (condition) {  
  myDynamicModule = require("foo");  
} else {  
  myDynamicModule = require("bar");  
}  
```  
  
但是CommonJS规范无法确定在实际运行前需要或者不需要某些模块，所以CommonJS不适合tree-shaking机制。在 ES6 中，引入了完全静态的导入语法：import。这也意味着下面的导入是不可行的：  
  
```javascript  
// 不可行，ES6 的import是完全静态的  
if (condition) {  
  myDynamicModule = require("foo");  
} else {  
  myDynamicModule = require("bar");  
}  
```  
  
我们只能通过导入所有的包后再进行条件获取。如下：  
  
```  
import foo from "foo";  
import bar from "bar";  
  
if (condition) {  
  // foo.xxxx  
} else {  
  // bar.xxx  
}  
```  
  
ES6的import语法可以完美使用tree shaking，因为可以在代码不运行的情况下就能分析出不需要的代码。  
  
看完上面的分析，你可能还是有点懵，这里我简单做下总结：因为tree shaking只能在静态modules下工作。ECMAScript 6 模块加载是静态的,因此整个依赖树可以被静态地推导出解析语法树。所以在 ES6 中使用 tree shaking 是非常容易的。  
  
## tree shaking的原理是什么?  
  
看完上面的分析，相信这里你可以很容易的得出题目的答案了：  
  
* ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块  
* 静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码  
# 前后端分离是什么？  
前后端分离，顾名思义，就是前端与后端分开。分开什么？分开开发，分开部署。  
  
这里以java web开发作为例子：我们学web开发的时候会接触到spring mvc框架，spring mvc开发时前端一般都用jsp作为展示页面，后端用servlet处理请求。再到springboot框架，前端使用thymeleaf或者freemarker作为模板引擎展示，后端用controller处理请求。  
  
其中jsp和thymeleaf，freemarker都有一个共同点：页面都是可以内嵌java代码的。页面里面嵌入了java（后端程序设计语言）代码，就导致页面和后端服务的耦合度特别高——前后端开发的时候粘在一起了。  
  
而如果我们要部署spring mvc/springboot的项目的话，前后端代码也都是打包在一个war包/jar包里的，部署的时候也是一起部署的，就导致前端要修改/后端要修改的话项目都要重新打包部署——前后端部署也粘在一起了。  
  
怎样才算分开开发呢？那当然就是前端页面只用写html + js + css，后端不用写jsp，不用使用thymeleaf等模板引擎来做html的渲染了。  
  
怎样才算分开部署呢？将前端项目和后端项目分开成两部分分别部署到服务器里。  
  
所以，前端项目和后端项目分开开发，分开部署的都算是前后端分离。  
  
## 我们为什么要前后端分离  
  
* 项目变大后难以更新维护  
  
我们也都知道，一个项目开发出来之后，都会一直更新维护。  
  
那每次项目更新升级都会添加新功能，代码量也会增加，项目也会越来越大。如果采取前后端不分离的开发方式，前后端的更新迭代对于前端工程师和后端工程师或是全栈工程师而言也是巨大的压力：当一个页面需要前端工程师和后端工程师一起才能做好的时候，对他们而言，沟通可能是比代码更令人头疼的问题；当一个项目开发团队都是全栈工程师，如果项目变大，首先令人头疼的问题应该是：怎样才能招到合格的全栈工程师——毕竟全栈工程师对程序员的要求更高。而且当前端页面或后端接口出现问题时，我们不得不重新打包编译整个项目以进行项目的更新与维护，而项目越大，打包与编译所耗费的时间就越长。  
  
* 项目耦合太严重难以复用  
  
上文也有提到，如果使用模板引擎或是jsp这种特殊的页面，都会出现在页面上写java代码的情况。那么如果想要进行代码复用，难度肯定是特别高的：每次复用后端接口都需要重新修改前端页面，并在上面添加java代码。  
  
* 项目加载更加耗费资源和时间  
  
如果要加载一个使用了thymeleaf的页面，首先我们需要调用thymeleaf引擎来解析页面上的java代码，然后再对页面进行渲染，而一般的静态页面只需要直接渲染就可以。如果我们项目需要承载更多的并发的时候，我们也只能将前后端结合的部署包进行多包部署以扩充系统性能，但这样也浪费了一部分资源。  
  
## 前后端分离有什么好处  
  
* 提升前端与后端开发效率  
  
前端与后端可以分开干了，各干各的，各自都只需要负责各自擅长的东西：前端只需要管html，css和js，后端只需要管java。只要商量确定好接口文档，甚至连开发进度都可以不统一：前端用js来mock数据进行测试，后端用postman等接口测试工具来做接口测试。  
  
* 项目更新维护变简单  
  
当我们需要更新维护前端页面时，只需要对前端项目的bug进行修缮，然后对前端项目进行打包部署就行，后端也是一样。而当团队需要扩招的时候，擅长单一职责（前端/后端）的人也更好找。  
  
* 提高接口复用率  
  
如果我们需要开发一个相似的项目，或者复用之前项目的后端模块，只需要将模块拿出来后进行小改动就行。而不是像以前一样大费周折，还要将接口对应的旧页面上的相应java代码移植到新的页面上（甚至还会出现不兼容的情况）。  
  
* 让页面加载变得更快  
  
我们将前端页面打包成静态页面进行部署，用户只需要访问静态页面就行，比起需要多一步解析交互代码的thymeleaf等模板引擎，普通的html页面肯定会快上一些，而有的时候这就不只是快上那么一点了。甚至我们可以引入nodejs作为中间岛，将前端页面的渲染放在nodejs上进行处理，直接将结果呈现反馈给浏览器。  
  
* 提升服务器资源利用率  
  
如果我们需要扩充系统并发量，只需要把前端页面在不超过后端接口QPS的情况下进行分包部署，做好负载均衡就行。而不需要将整个项目分包部署，尤其是多部署后端服务——这特别占用服务器资源。而如果超过了后端接口的QPS，后端当然也要分包部署了。  
  
## 前后端分离带来的问题  
  
* 跨域问题（CORS）  
  
跨域问题应该是最常见的问题了。当我们用到Ajax进行数据请求的时候，跨域问题就会出现。这个问题的解决方法也是特别简单的，后端在返回的请求header中添加Access-Control-Allow-Origin就可以解决了。不同应用场景有不同设置方法，而这个问题百度来答案比什么都快。  
  
* 单点登录问题  
  
这个问题也是最近我在做项目对接的时候遇到的，具体是在对接cas的单点认证时，请求服务的单点登录接口是直接接入门户网站的，而这个接口对接的是后端而不是前端。当我们从门户访问接入应用的单点登录链接时，请求是直接发送到后端的。由于前端没接入nodejs，所以并没有办法将请求直接发送到前端进行登录验证。而整个认证流程都在后端进行的话，前端页面就无法正常获取登录后的jwt了。所以要在第一步请求的时候，将生成的token和jsessionid写入前端的认证处理页面来做页面跳转和登录认证的进一步进行。  
  
  
# 与webpack类似的工具还有哪些？区别？  
  
![](https://static.vue-js.com/8ed8d520-b1a4-11eb-85f6-6fac77c0c9b3.png)  
  
## 一、模块化工具  
  
模块化是一种处理复杂系统分解为更好的可管理模块的方式  
  
可以用来分割，组织和打包应用。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(`bundle`)  
  
在前端领域中，并非只有`webpack`这一款优秀的模块打包工具，还有其他类似的工具，例如`Rollup`、`Parcel`、`snowpack`，以及最近风头无两的`Vite`  
  
通过这些模块打包工具，能够提高我们的开发效率，减少开发成本  
  
这里没有提及`gulp`、`grunt`是因为它们只是定义为构建工具，不能类比  
  
### Rollup  
  
`Rollup` 是一款 `ES Modules` 打包器，从作用上来看，`Rollup` 与 `Webpack` 非常类似。不过相比于 `Webpack`，`Rollup `要小巧的多  
  
现在很多我们熟知的库都都使用它进行打包，比如：`Vue`、`React`和`three.js`等  
  
举个例子：  
  
```js  
// ./src/messages.js  
export default {  
  hi: 'Hey Guys, I am zce~'  
}  
  
// ./src/logger.js  
export const log = msg => {  
  console.log('---------- INFO ----------')  
  console.log(msg)  
  console.log('--------------------------')  
}  
  
export const error = msg => {  
  console.error('---------- ERROR ----------')  
  console.error(msg)  
  console.error('---------------------------')  
}  
  
// ./src/index.js  
import { log } from './logger'  
import messages from './messages'  
log(messages.hi)  
```  
  
然后通过`rollup`进行打包  
  
```js  
$ npx rollup ./src/index.js --file ./dist/bundle.js  
```  
  
打包结果如下图![](https://static.vue-js.com/8fe07830-b143-11eb-85f6-6fac77c0c9b3.png)  
  
可以看到，代码非常简洁，完成不像`webpack`那样存在大量引导代码和模块函数  
  
并且`error`方法由于没有被使用，输出的结果中并无`error`方法，可以看到，`rollup`默认开始`Tree-shaking` 优化输出结果  
  
因此，可以看到`Rollup`的优点：  
  
- 代码效率更简洁、效率更高  
- 默认支持 Tree-shaking  
  
但缺点也十分明显，加载其他类型的资源文件或者支持导入 `CommonJS` 模块，又或是编译 `ES` 新特性，这些额外的需求 `Rollup `需要使用插件去完成  
  
综合来看，`rollup`并不适合开发应用使用，因为需要使用第三方模块，而目前第三方模块大多数使用`CommonJs`方式导出成员，并且`rollup`不支持`HMR`，使开发效率降低  
  
但是在用于打包` JavaScript` 库时，`rollup`比 `webpack` 更有优势，因为其打包出来的代码更小、更快，其存在的缺点可以忽略  
  
  
  
  
  
### Parcel  
  
Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序  
  
`Parcel` 跟 `Webpack` 一样都支持以任意类型文件作为打包入口，但建议使用`HTML`文件作为入口，该`HTML`文件像平时一样正常编写代码、引用资源。如下所示：  
  
```js  
<!-- ./src/index.html -->  
<!DOCTYPE html>  
<html lang="en">  
<head>  
  <meta charset="UTF-8">  
  <title>Parcel Tutorials</title>  
</head>  
<body>  
  <script src="main.js"></script>  
</body>  
</html>  
```  
  
main.js文件通过`ES Moudle`方法导入其他模块成员  
  
```js  
// ./src/main.js  
import { log } from './logger'  
log('hello parcel')  
// ./src/logger.js  
export const log = msg => {  
  console.log('---------- INFO ----------')  
  console.log(msg)  
}  
```  
  
运行之后，使用命令打包  
  
```cmd  
npx parcel src/index.html  
```  
  
执行命令后，`Parcel`不仅打包了应用，同时也启动了一个开发服务器，跟`webpack Dev Server`一样  
  
跟`webpack`类似，也支持模块热替换，但用法更简单  
  
同时，`Parcel`有个十分好用的功能：支持自动安装依赖，像`webpack`开发阶段突然使用安装某个第三方依赖，必然会终止`dev server`然后安装再启动。而`Parcel`则免了这繁琐的工作流程  
  
同时，`Parcel`能够零配置加载其他类型的资源文件，无须像`webpack`那样配置对应的`loader`  
  
打包命令如下：  
  
```cmd  
npx parcel src/index.html  
```  
  
由于打包过程是多进程同时工作，构建速度会比`Webpack` 快，输出文件也会被压缩，并且样式代码也会被单独提取到单个文件中  
  
![](https://static.vue-js.com/ec17e7a0-b1a2-11eb-85f6-6fac77c0c9b3.png)  
  
可以感受到，`Parcel `给开发者一种很大的自由度，只管去实现业务代码，其他事情用`Parcel`解决  
  
  
  
### Snowpack  
  
Snowpack，是一种闪电般快速的前端构建工具，专为现代`Web`设计，较复杂的打包工具（如`Webpack`或`Parcel`）的替代方案，利用`JavaScript`的本机模块系统，避免不必要的工作并保持流畅的开发体验  
  
开发阶段，每次保存单个文件时，`Webpack`和`Parcel`都需要重新构建和重新打包应用程序的整个`bundle`。而`Snowpack`为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，`Snowpack`会重新构建该单个文件  
  
下图给出`webpack`与`snowpack`打包区别：  
  
 ![](https://static.vue-js.com/79197830-b1a3-11eb-85f6-6fac77c0c9b3.png)  
  
在重新构建每次变更时没有任何的时间浪费，只需要在浏览器中进行HMR更新  
  
### Vite  
  
vite ，是一种新型前端构建工具，能够显著提升前端开发体验  
  
它主要由两部分组成：  
  
- 一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的 [模块热更新HMR  
- 一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源  
  
其作用类似`webpack `+ `webpack-dev-server`，其特点如下：  
  
- 快速的冷启动  
- 即时的模块热更新  
- 真正的按需编译  
  
`vite`会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快  
  
利用现代浏览器支持`ES Module`的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间  
  
原理图如下所示：  
  
 ![](https://static.vue-js.com/9f2eed30-b143-11eb-85f6-6fac77c0c9b3.png)  
  
在热模块`HMR`方面，当修改一个模块的时候，仅需让浏览器重新请求该模块即可，无须像`webpack`那样需要把该模块的相关依赖模块全部编译一次，效率更高  
  
  
  
### webpack  
  
相比上述的模块化工具，`webpack`大而全，很多常用的功能做到开箱即用。有两大最核心的特点：**一切皆模块**和**按需加载**  
  
与其他构建工具相比，有如下优势：  
  
- 智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容  
- 万物模块：对 js、css、图片等资源文件都支持打包  
- 开箱即用：HRM、Tree-shaking等功能  
- 代码分割：可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间  
- 插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性  
- 易于调试：支持 SourceUrls 和 SourceMaps  
- 快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快  
- 生态环境好：社区更丰富，出现的问题更容易解决  
  
# 如何提高webpack的构建速度？  
  
 ![](https://static.vue-js.com/3a1b8620-b01b-11eb-85f6-6fac77c0c9b3.png)  
  
## 一、背景  
  
随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 `webpack` 的构建时间也会越来越久  
  
构建时间与我们日常开发效率密切相关，当我们本地开发启动 `devServer` 或者 `build` 的时候，如果时间过长，会大大降低我们的工作效率  
  
所以，优化`webpack` 构建速度是十分重要的环节  
  
  
## 二、如何优化  
  
常见的提升构建速度的手段有如下：  
  
- 优化 loader 配置  
- 合理使用 resolve.extensions  
- 优化 resolve.modules  
- 优化 resolve.alias  
- 使用 DLLPlugin 插件  
- 使用 cache-loader  
- terser 启动多线程  
- 合理使用 sourceMap  
  
  
  
  
  
### 优化loader配置  
  
在使用`loader`时，可以通过配置`include`、`exclude`、`test`属性来匹配文件，接触`include`、`exclude`规定哪些匹配应用`loader`  
  
如采用 ES6 的项目为例，在配置 `babel-loader `时，可以这样：  
  
```js  
module.exports = {  
  module: {  
    rules: [  
      {  
        // 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能  
        test: /\.js$/,  
        // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启  
        use: ['babel-loader?cacheDirectory'],  
        // 只对项目根目录下的 src 目录中的文件采用 babel-loader  
        include: path.resolve(__dirname, 'src'),  
      },  
    ]  
  },  
};  
```  
  
  
  
### 合理使用 resolve.extensions  
  
在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， `resolve`可以帮助`webpack`从每个 `require/import` 语句中，找到需要引入到合适的模块代码  
  
通过`resolve.extensions`是解析到文件时自动添加拓展名，默认情况如下：  
  
```js  
module.exports = {  
    ...  
    extensions:[".warm",".mjs",".js",".json"]  
}  
```  
  
当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找  
  
当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度  
  
  
  
### 优化 resolve.modules  
  
`resolve.modules` 用于配置 `webpack` 去哪些目录下寻找第三方模块。默认值为`['node_modules']`，所以默认会从`node_modules`中查找文件  
当安装的第三方模块都放在项目根目录下的 `./node_modules `目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：  
  
```  
module.exports = {  
  resolve: {  
    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤  
    // 其中 __dirname 表示当前工作目录，也就是项目根目录  
    modules: [path.resolve(__dirname, 'node_modules')]  
  },  
};  
```  
  
  
  
### 优化 resolve.alias   
  
`alias`给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是`./../../`的形式  
  
通过配置`alias`以减少查找过程  
  
```js  
module.exports = {  
    ...  
    resolve:{  
        alias:{  
            "@":path.resolve(__dirname,'./src')  
        }  
    }  
}  
```  
  
  
  
  
  
### 使用 DLLPlugin 插件  
  
`DLL`全称是 动态链接库，是为软件在winodw种实现共享函数库的一种实现方式，而Webpack也内置了DLL的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中  
  
使用步骤分成两部分：  
  
- 打包一个 DLL 库  
- 引入 DLL 库  
  
#### 打包一个 DLL 库  
  
`webpack`内置了一个`DllPlugin`可以帮助我们打包一个DLL的库文件  
  
```js  
module.exports = {  
    ...  
    plugins:[  
        new webpack.DllPlugin({  
            name:'dll_[name]',  
            path:path.resolve(__dirname,"./dll/[name].mainfest.json")  
        })  
    ]  
}  
```  
  
  
  
#### 引入 DLL 库  
  
使用 `webpack` 自带的 `DllReferencePlugin` 插件对 `mainfest.json` 映射文件进行分析，获取要使用的`DLL`库  
  
然后再通过`AddAssetHtmlPlugin`插件，将我们打包的`DLL`库引入到`Html`模块中  
  
```js  
module.exports = {  
    ...  
    new webpack.DllReferencePlugin({  
        context:path.resolve(__dirname,"./dll/dll_react.js"),  
        mainfest:path.resolve(__dirname,"./dll/react.mainfest.json")  
    }),  
    new AddAssetHtmlPlugin({  
        outputPath:"./auto",  
        filepath:path.resolve(__dirname,"./dll/dll_react.js")  
    })  
}  
```  
  
  
  
### 使用 cache-loader  
  
在一些性能开销较大的 `loader `之前添加 `cache-loader`，以将结果缓存到磁盘里，显著提升二次构建速度  
  
保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 `loader` 使用此` loader`  
  
```js  
module.exports = {  
    module: {  
        rules: [  
            {  
                test: /\.ext$/,  
                use: ['cache-loader', ...loaders],  
                include: path.resolve('src'),  
            },  
        ],  
    },  
};  
```  
  
  
  
### terser 启动多线程  
  
使用多进程并行运行来提高构建速度  
  
```js  
module.exports = {  
  optimization: {  
    minimizer: [  
      new TerserPlugin({  
        parallel: true,  
      }),  
    ],  
  },  
};  
```  
  
  
  
### 合理使用 sourceMap  
  
打包生成  `sourceMap` 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：  
  
![](https://static.vue-js.com/11647af0-b01d-11eb-85f6-6fac77c0c9b3.png)  
  
  
  
  
  
### 三、总结  
  
可以看到，优化`webpack`构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手  
  
# 说说如何借助webpack来优化前端性能？  
  
  
 ![](https://static.vue-js.com/15e1ace0-aee4-11eb-ab90-d9ae814b240d.png)  
  
  
  
## 一、背景  
  
随着前端的项目逐渐扩大，必然会带来的一个问题就是性能  
  
尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃  
  
一般项目在完成后，会通过`webpack`进行打包，利用`webpack`对前端项目性能优化是一个十分重要的环节  
  
  
  
## 二、如何优化  
  
  
  
通过`webpack`优化前端的手段有：  
  
- JS代码压缩  
- CSS代码压缩  
- Html文件代码压缩  
- 文件大小压缩  
- 图片压缩  
- Tree Shaking  
- 代码分离  
- 内联 chunk  
  
  
  
### JS代码压缩  
  
`terser`是一个`JavaScript`的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让`bundle`更小  
  
在`production`模式下，`webpack` 默认就是使用 `TerserPlugin` 来处理我们的代码的。如果想要自定义配置它，配置方法如下：  
  
```js  
const TerserPlugin = require('terser-webpack-plugin')  
module.exports = {  
    ...  
    optimization: {  
        minimize: true,  
        minimizer: [  
            new TerserPlugin({  
                parallel: true // 电脑cpu核数-1  
            })  
        ]  
    }  
}  
```  
  
属性介绍如下：  
  
-  extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释  
-  parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1  
-  terserOptions：设置我们的terser相关的配置：  
   - compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true  
   - mangle：设置丑化相关的选项，可以直接设置为true  
   - toplevel：底层变量是否进行转换  
   - keep_classnames：保留类的名称  
   - keep_fnames：保留函数的名称  
  
  
  
### CSS代码压缩  
  
`CSS`压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等  
  
CSS的压缩我们可以使用另外一个插件：`css-minimizer-webpack-plugin`  
  
```cmd  
npm install css-minimizer-webpack-plugin -D  
```  
  
配置方法如下：  
  
```js  
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin')  
module.exports = {  
    // ...  
    optimization: {  
        minimize: true,  
        minimizer: [  
            new CssMinimizerPlugin({  
                parallel: true  
            })  
        ]  
    }  
}  
```  
  
  
  
  
  
### Html文件代码压缩  
  
使用`HtmlWebpackPlugin`插件来生成`HTML`的模板时候，通过配置属性`minify`进行`html`优化  
  
```js  
module.exports = {  
    ...  
    plugin:[  
        new HtmlwebpackPlugin({  
            ...  
            minify:{  
                minifyCSS:false, // 是否压缩css  
                collapseWhitespace:false, // 是否折叠空格  
                removeComments:true // 是否移除注释  
            }  
        })  
    ]  
}  
```  
  
设置了`minify`，实际会使用另一个插件`html-minifier-terser`  
  
  
  
### 文件大小压缩  
  
对文件的大小进行压缩，减少`http`传输过程中宽带的损耗  
  
```js  
npm install compression-webpack-plugin -D  
```  
  
```js  
new ComepressionPlugin({  
    test:/\.(css|js)$/,  // 哪些文件需要压缩  
    threshold:500, // 设置文件多大开始压缩  
    minRatio:0.7, // 至少压缩的比例  
    algorithm:"gzip", // 采用的压缩算法  
})  
```  
  
  
  
  
  
### 图片压缩  
  
一般来说在打包之后，一些图片文件的大小是远远要比 `js` 或者 `css` 文件要来的大，所以图片压缩较为重要  
  
配置方法如下：  
  
```js  
module: {  
  rules: [  
    {  
      test: /\.(png|jpg|gif)$/,  
      use: [  
        {  
          loader: 'file-loader',  
          options: {  
            name: '[name]_[hash].[ext]',  
            outputPath: 'images/',  
          }  
        },  
        {  
          loader: 'image-webpack-loader',  
          options: {  
            // 压缩 jpeg 的配置  
            mozjpeg: {  
              progressive: true,  
              quality: 65  
            },  
            // 使用 imagemin**-optipng 压缩 png，enable: false 为关闭  
            optipng: {  
              enabled: false,  
            },  
            // 使用 imagemin-pngquant 压缩 png  
            pngquant: {  
              quality: '65-90',  
              speed: 4  
            },  
            // 压缩 gif 的配置  
            gifsicle: {  
              interlaced: false,  
            },  
            // 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式  
            webp: {  
              quality: 75  
            }  
          }  
        }  
      ]  
    },  
  ]  
}   
```  
  
  
  
  
  
### Tree Shaking  
  
`Tree Shaking` 是一个术语，在计算机中表示消除死代码，依赖于`ES Module`的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）  
  
在`webpack`实现`Trss shaking`有两种不同的方案：  
  
- usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的  
- sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用  
  
两种不同的配置方案， 有不同的效果  
  
  
  
#### usedExports  
  
配置方法也很简单，只需要将`usedExports`设为`true`  
  
```js  
module.exports = {  
    ...  
    optimization:{  
        usedExports  
    }  
}  
```  
  
使用之后，没被用上的代码在`webpack`打包中会加入`unused harmony export mul`注释，用来告知 `Terser` 在优化时，可以删除掉这段代码  
  
 如下面`sum`函数没被用到，`webpack`打包会添加注释，`terser`在优化时，则将该函数去掉  
  
 ![](https://static.vue-js.com/21b2e200-aee4-11eb-85f6-6fac77c0c9b3.png)  
  
  
  
  
  
#### sideEffects  
  
`sideEffects`用于告知`webpack compiler`哪些模块时有副作用，配置方法是在`package.json`中设置`sideEffects`属性  
  
如果`sideEffects`设置为false，就是告知`webpack`可以安全的删除未用到的`exports`  
  
如果有些文件需要保留，可以设置为数组的形式  
  
```js  
"sideEffecis":[    "./src/util/format.js",    "*.css" // 所有的css文件]  
```  
  
  
  
上述都是关于`javascript`的`tree shaking`，`css`同样也能够实现`tree shaking`  
  
#### css tree shaking  
  
`css`进行`tree shaking`优化可以安装`PurgeCss`插件  
  
```cmd  
npm install purgecss-plugin-webpack -D  
```  
  
```js  
const PurgeCssPlugin = require('purgecss-webpack-plugin')module.exports = {    ...    plugins:[        new PurgeCssPlugin({            path:glob.sync(`${path.resolve('./src')}/**/*`), {nodir:true}// src里面的所有文件            satelist:function(){                return {                    standard:["html"]                }            }        })    ]}  
```  
  
- paths：表示要检测哪些目录下的内容需要被分析，配合使用glob  
- 默认情况下，Purgecss会将我们的html标签的样式移除掉，如果我们希望保留，可以添加一个safelist的属性  
  
  
  
### 代码分离  
  
将代码分离到不同的`bundle`中，之后我们可以按需加载，或者并行加载这些文件  
  
默认情况下，所有的`JavaScript`代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度  
  
代码分离可以分出出更小的`bundle`，以及控制资源加载优先级，提供代码的加载性能  
  
这里通过`splitChunksPlugin`来实现，该插件`webpack`已经默认安装和集成，只需要配置即可  
  
默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为initial或者all  
  
```js  
module.exports = {    ...    optimization:{        splitChunks:{            chunks:"all"        }    }}  
```  
  
`splitChunks`主要属性有如下：  
  
- Chunks，对同步代码还是异步代码进行处理  
- minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分  
- maxSize： 将大于maxSize的包，拆分为不小于minSize的包  
- minChunks：被引入的次数，默认是1  
  
  
  
### 内联chunk  
  
可以通过`InlineChunkHtmlPlugin`插件将一些`chunk`的模块内联到`html`，如`runtime`的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的  
  
```js  
const InlineChunkHtmlPlugin = require('react-dev-utils/InlineChunkHtmlPlugin')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = {    ...    plugin:[        new InlineChunkHtmlPlugin(HtmlWebpackPlugin,[/runtime.+\.js/]}  
```  
  
  
  
  
  
### 三、总结  
  
关于`webpack`对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少http请求次数等方式，实现对前端性能的优化  
  
# 说说webpack的热更新是如何做到的？原理是什么？  
  
 ![](https://static.vue-js.com/a076da40-acd4-11eb-85f6-6fac77c0c9b3.png)  
  
### 一、是什么  
  
`HMR `全称 `Hot Module Replacement`，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用  
  
例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失  
  
如果使用的是 `HMR`，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用  
  
在`webpack`中配置开启热模块也非常的简单，如下代码：  
  
```js  
const webpack = require('webpack')  
module.exports = {  
  // ...  
  devServer: {  
    // 开启 HMR 特性  
    hot: true  
    // hotOnly: true  
  }  
}  
```  
  
通过上述这种配置，如果我们修改并保存`css`文件，确实能够以不刷新的形式更新到页面中  
  
但是，当我们修改并保存`js`文件之后，页面依旧自动刷新了，这里并没有触发热模块  
  
所以，`HMR `并不像 `Webpack` 的其他特性一样可以开箱即用，需要有一些额外的操作  
  
我们需要去指定哪些模块发生更新时进行`HRM`，如下代码：  
  
```js  
if(module.hot){  
    module.hot.accept('./util.js',()=>{  
        console.log("util.js更新了")  
    })  
}  
```  
  
  
  
## 二、实现原理  
  
首先来看看一张图，如下：  
  
 ![](https://static.vue-js.com/adc05780-acd4-11eb-ab90-d9ae814b240d.png)  
  
- Webpack Compile：将 JS 源代码编译成 bundle.js  
- HMR Server：用来将热更新的文件输出给 HMR Runtime  
- Bundle Server：静态资源文件服务器，提供文件访问路径  
- HMR Runtime：socket服务器，会被注入到浏览器，更新文件的变化  
- bundle.js：构建输出的文件  
- 在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化  
  
上面图中，可以分成两个阶段：  
  
- 启动阶段为上图 1 - 2 - A - B  
  
在编写未经过`webpack`打包的源代码后，`Webpack Compile` 将源代码和 `HMR Runtime` 一起编译成 `bundle `文件，传输给` Bundle Server` 静态资源服务器  
  
- 更新阶段为上图 1 - 2 - 3 - 4  
  
当某一个文件或者模块发生变化时，`webpack `监听到文件变化对文件重新编译打包，编译生成唯一的` hash `值，这个`hash `值用来作为下一次热更新的标识  
  
根据变化的内容生成两个补丁文件：`manifest`（包含了 `hash` 和 `chundId `，用来说明变化的内容）和` chunk.js` 模块  
  
由于`socket`服务器在`HMR Runtime` 和 `HMR Server`之间建立 `websocket`链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的`hash`值，如下图的`h`属性，作为下一次热更细的标识  
  
 ![](https://static.vue-js.com/05a0edf0-ad4a-11eb-85f6-6fac77c0c9b3.png)  
  
在浏览器接受到这条消息之前，浏览器已经在上一次` socket` 消息中已经记住了此时的` hash` 标识，这时候我们会创建一个 `ajax` 去服务端请求获取到变化内容的 `manifest` 文件  
  
`mainfest`文件包含重新`build`生成的`hash`值，以及变化的模块，对应上图的`c`属性  
  
浏览器根据 `manifest` 文件获取模块变化的内容，从而触发`render`流程，实现局部模块更新  
  
 ![](https://static.vue-js.com/0e7b7850-ad4a-11eb-ab90-d9ae814b240d.png)  
  
  
  
## 三、总结  
  
关于`webpack`热模块更新的总结如下：  
  
- 通过`webpack-dev-server`创建两个服务器：提供静态资源的服务（express）和Socket服务  
- express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）  
- socket server 是一个 websocket 的长连接，双方可以通信  
- 当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）  
- 通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）  
- 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新  
  
# 说说webpack proxy工作原理？为什么能解决跨域?  
  
 ![](https://static.vue-js.com/5b871600-ace5-11eb-85f6-6fac77c0c9b3.png)  
  
## 一、是什么  
  
`webpack proxy`，即`webpack`提供的代理服务  
  
基本行为就是接收客户端发送的请求后转发给其他服务器  
  
其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）  
  
想要实现代理首先需要一个中间服务器，`webpack`中提供服务器的工具为`webpack-dev-server`  
  
#### webpack-dev-server  
  
`webpack-dev-server`是 `webpack` 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起  
  
目的是为了提高开发者日常的开发效率，**只适用在开发阶段**  
  
关于配置方面，在`webpack`配置对象属性中通过`devServer`属性提供，如下：  
  
```js  
// ./webpack.config.js  
const path = require('path')  
  
module.exports = {  
    // ...  
    devServer: {  
        contentBase: path.join(__dirname, 'dist'),  
        compress: true,  
        port: 9000,  
        proxy: {  
            '/api': {  
                target: 'https://api.github.com'  
            }  
        }  
        // ...  
    }  
}  
```  
  
`devServetr`里面`proxy`则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配  
  
属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为` /api`，值为对应的代理匹配规则，对应如下：  
  
- target：表示的是代理到的目标地址  
- pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite  
- secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false  
- changeOrigin：它表示是否更新代理后请求的 headers 中host地址  
  
  
  
  
  
## 二、工作原理  
  
 `proxy`工作原理实质上是利用`http-proxy-middleware` 这个`http`代理中间件，实现请求转发给其他服务器  
  
举个例子：  
  
在开发阶段，本地地址为`http://localhost:3000`，该浏览器发送一个前缀带有`/api`标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中  
  
```js  
const express = require('express');  
const proxy = require('http-proxy-middleware');  
  
const app = express();  
  
app.use('/api', proxy({target: 'http://www.example.org', changeOrigin: true}));  
app.listen(3000);  
  
// http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar  
```  
  
  
  
## 三、跨域  
  
在开发阶段， `webpack-dev-server` 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 `localhost `的一个端口上，而后端服务又是运行在另外一个地址上  
  
所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题  
  
通过设置`webpack proxy`实现代理请求后，相当于浏览器与服务端中添加一个代理者  
  
当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地  
  
 ![](https://static.vue-js.com/65b5e5c0-ace5-11eb-85f6-6fac77c0c9b3.png)  
  
在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据  
  
注意：**服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制**  
  
  
# 面试官：说说Loader和Plugin的区别？编写Loader，Plugin的思路？  
![](https://static.vue-js.com/93042280-a894-11eb-ab90-d9ae814b240d.png)  
  
## 一、区别  
  
前面两节我们有提到`Loader`与`Plugin`对应的概念，先来回顾下  
  
- loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中  
- plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事  
  
从整个运行时机上来看，如下图所示：  
  
![](https://static.vue-js.com/9a04ec40-a7c2-11eb-ab90-d9ae814b240d.png)  
  
可以看到，两者在运行时机上的区别：  
  
-  loader 运行在打包文件之前  
-  plugins 在整个编译周期都起作用  
  
在` Webpack` 运行的生命周期中会广播出许多事件，`Plugin` 可以监听这些事件，在合适的时机通过` Webpack `提供的 `API `改变输出结果  
  
对于`loader`，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将`A.scss`或`A.less`转变为`B.css`，单纯的文件转换过程  
  
  
  
## 二、编写loader  
  
在编写 `loader` 前，我们首先需要了解 `loader` 的本质  
  
其本质为函数，函数中的 `this` 作为上下文会被 `webpack` 填充，因此我们不能将 `loader`设为一个箭头函数  
  
函数接受一个参数，为 `webpack` 传递给 `loader` 的文件源内容  
  
函数中 `this` 是由 `webpack` 提供的对象，能够获取当前 `loader` 所需要的各种信息  
  
函数中有异步操作或同步操作，异步操作通过 `this.callback` 返回，返回值要求为 `string` 或者 `Buffer`  
  
代码如下所示：  
  
```js  
// 导出一个函数，source为webpack传递给loader的文件源内容  
module.exports = function(source) {  
    const content = doSomeThing2JsString(source);  
      
    // 如果 loader 配置了 options 对象，那么this.query将指向 options  
    const options = this.query;  
      
    // 可以用作解析其他模块路径的上下文  
    console.log('this.context');  
      
    /*  
     * this.callback 参数：  
     * error：Error | null，当 loader 出错时向外抛出一个 error  
     * content：String | Buffer，经过 loader 编译后需要导出的内容  
     * sourceMap：为方便调试生成的编译后内容的 source map  
     * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程  
     */  
    this.callback(null, content); // 异步  
    return content; // 同步  
}  
```  
  
一般在编写`loader`的过程中，保持功能单一，避免做多种功能  
  
如` less `文件转换成 `css `文件也不是一步到位，而是 `less-loader`、`css-loader`、` style-loader `几个 `loader `的链式调用才能完成转换  
  
  
  
## 三、编写plugin  
  
由于`webpack`基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务  
  
在之前也了解过，`webpack`编译会创建两个核心对象：  
  
- compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子  
- compilation：作为 plugin 内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建  
  
如果自己要实现`plugin`，也需要遵循一定的规范：  
  
- 插件必须是一个函数或者是一个包含 `apply` 方法的对象，这样才能访问`compiler`实例  
- 传给每个插件的 `compiler` 和 `compilation` 对象都是同一个引用，因此不建议修改  
- 异步的事件需要在插件处理完任务时调用回调函数通知 `Webpack` 进入下一个流程，不然会卡住  
  
  
  
实现`plugin`的模板如下：  
  
```js  
class MyPlugin {  
    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象  
  apply (compiler) {  
    // 找到合适的事件钩子，实现自己的插件功能  
    compiler.hooks.emit.tap('MyPlugin', compilation => {  
        // compilation: 当前打包构建流程的上下文  
        console.log(compilation);  
          
        // do something...  
    })  
  }  
}  
```  
  
在 `emit` 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容  
  
# 说说webpack中常见的Plugin？解决了什么问题？  
 ![](https://static.vue-js.com/8d3978a0-a7c2-11eb-85f6-6fac77c0c9b3.png)  
  
## 一、是什么  
  
`Plugin`（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能  
  
是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用原纯净系统提供的函数库或者数据  
  
`webpack`中的`plugin`也是如此，`plugin`赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 `webpack` 的不同阶段（钩子 / 生命周期），贯穿了`webpack`整个编译周期  
  
![](https://static.vue-js.com/9a04ec40-a7c2-11eb-ab90-d9ae814b240d.png)  
  
目的在于解决`loader` 无法实现的其他事  
  
### 配置方式  
  
这里讲述文件的配置方式，一般情况，通过配置文件导出对象中`plugins`属性传入`new`实例对象。如下所示：  
  
```js  
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装  
const webpack = require('webpack'); // 访问内置的插件  
module.exports = {  
  ...  
  plugins: [  
    new webpack.ProgressPlugin(),  
    new HtmlWebpackPlugin({ template: './src/index.html' }),  
  ],  
};  
```  
  
  
  
## 二、特性  
  
其本质是一个具有`apply`方法`javascript`对象  
  
`apply` 方法会被 `webpack compiler `调用，并且在整个编译生命周期都可以访问 `compiler `对象  
  
```javascript  
const pluginName = 'ConsoleLogOnBuildWebpackPlugin';  
  
class ConsoleLogOnBuildWebpackPlugin {  
  apply(compiler) {  
    compiler.hooks.run.tap(pluginName, (compilation) => {  
      console.log('webpack 构建过程开始！');  
    });  
  }  
}  
  
module.exports = ConsoleLogOnBuildWebpackPlugin;  
```  
  
`compiler hook` 的 `tap `方法的第一个参数，应是驼峰式命名的插件名称  
  
关于整个编译生命周期钩子，有如下：  
  
- entry-option ：初始化 option  
- run  
- compile： 真正开始的编译，在创建 compilation 对象之前  
- compilation ：生成好了 compilation 对象  
- make 从 entry 开始递归分析依赖，准备对每个模块进行 build  
- after-compile： 编译 build 过程结束  
- emit ：在将内存中 assets 内容写到磁盘文件夹之前  
- after-emit ：在将内存中 assets 内容写到磁盘文件夹之后  
- done： 完成所有的编译过程  
- failed： 编译失败的时候  
  
  
  
## 三、常见的Plugin  
  
常见的`plugin`有如图所示：  
  
![](https://static.vue-js.com/bd749400-a7c2-11eb-85f6-6fac77c0c9b3.png)  
  
  
  
下面介绍几个常用的插件用法：  
  
### HtmlWebpackPlugin  
  
在打包结束后，⾃动生成⼀个 `html` ⽂文件，并把打包生成的` js` 模块引⼊到该 `html` 中  
  
```bash  
npm install --save-dev html-webpack-plugin  
```  
  
```js  
// webpack.config.js  
const HtmlWebpackPlugin = require("html-webpack-plugin");  
module.exports = {  
 ...  
  plugins: [  
     new HtmlWebpackPlugin({  
       title: "My App",  
       filename: "app.html",  
       template: "./src/html/index.html"  
     })   
  ]  
};  
```  
  
```html  
<!--./src/html/index.html-->  
<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <meta http-equiv="X-UA-Compatible" content="ie=edge">  
    <title><%=htmlWebpackPlugin.options.title%></title>  
</head>  
<body>  
    <h1>html-webpack-plugin</h1>  
</body>  
</html>  
```  
  
在 `html` 模板中，可以通过 `<%=htmlWebpackPlugin.options.XXX%>` 的方式获取配置的值  
  
更多的配置可以自寻查找  
  
  
  
### clean-webpack-plugin  
  
删除（清理）构建目录  
  
```bash  
npm install --save-dev clean-webpack-plugin  
```  
  
```js  
const {CleanWebpackPlugin} = require('clean-webpack-plugin');  
module.exports = {  
 ...  
  plugins: [  
    ...,  
    new CleanWebpackPlugin(),  
    ...  
  ]  
}  
```  
  
  
  
### mini-css-extract-plugin  
  
提取 `CSS` 到一个单独的文件中  
  
```bash  
npm install --save-dev mini-css-extract-plugin  
```  
  
```js  
const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = { ...,  module: {   rules: [    {     test: /\.s[ac]ss$/,     use: [      {       loader: MiniCssExtractPlugin.loader     },          'css-loader',          'sass-loader'        ]   }   ] },  plugins: [    ...,    new MiniCssExtractPlugin({     filename: '[name].css'    }),    ...  ]}  
```  
  
  
  
### DefinePlugin  
  
允许在编译时创建配置的全局对象，是一个`webpack`内置的插件，不需要安装  
  
```js  
const { DefinePlugun } = require('webpack')module.exports = { ...    plugins:[        new DefinePlugin({            BASE_URL:'"./"'        })    ]}  
```  
  
这时候编译`template`模块的时候，就能通过下述形式获取全局对象  
  
```html  
<link rel="icon" href="<%= BASE_URL%>favicon.ico>"  
```  
  
  
  
  
  
### copy-webpack-plugin  
  
复制文件或目录到执行区域，如`vue`的打包过程中，如果我们将一些文件放到`public`的目录下，那么这个目录会被复制到`dist`文件夹中  
  
```cmd  
npm install copy-webpack-plugin -D  
```  
  
```js  
new CopyWebpackPlugin({    parrerns:[        {            from:"public",            globOptions:{                ignore:[                    '**/index.html'                ]            }        }    ]})  
```  
  
复制的规则在`patterns`属性中设置：  
  
- from：设置从哪一个源中开始复制  
- to：复制到的位置，可以省略，会默认复制到打包的目录下  
  
- globOptions：设置一些额外的选项，其中可以编写需要忽略的文件  
  
  
# 说说webpack中常见的Loader？解决了什么问题？  
 ![](https://static.vue-js.com/5660fc40-a6ff-11eb-85f6-6fac77c0c9b3.png)  
  
## 一、是什么  
  
`loader` 用于对模块的"源代码"进行转换，在 `import` 或"加载"模块时预处理文件  
  
`webpack`做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。如下图所示：  
  
 ![](https://static.vue-js.com/7b8d9640-a6ff-11eb-ab90-d9ae814b240d.png)  
  
在`webpack`内部中，任何文件都是模块，不仅仅只是`js`文件  
  
默认情况下，在遇到`import`或者`load`加载模块的时候，`webpack`只支持对`js`文件打包  
  
像`css`、`sass`、`png`等这些类型的文件的时候，`webpack`则无能为力，这时候就需要配置对应的`loader`进行文件内容的解析  
  
在加载模块的时候，执行顺序如下：  
  
 ![](https://static.vue-js.com/9c2c43b0-a6ff-11eb-85f6-6fac77c0c9b3.png)  
  
  
  
当 `webpack` 碰到不识别的模块的时候，`webpack` 会在配置的中查找该文件解析规则  
  
  
  
关于配置`loader`的方式有三种：  
  
- 配置方式（推荐）：在 webpack.config.js文件中指定 loader  
- 内联方式：在每个 import 语句中显式指定 loader  
- CLI 方式：在 shell 命令中指定它们  
  
  
### 配置方式  
  
关于`loader`的配置，我们是写在`module.rules`属性中，属性介绍如下：  
  
- `rules`是一个数组的形式，因此我们可以配置很多个`loader`  
  
- 每一个`loader`对应一个对象的形式，对象属性`test` 为匹配的规则，一般情况为正则表达式  
  
- 属性`use`针对匹配到文件类型，调用对应的 `loader` 进行处理  
  
代码编写，如下形式：  
  
```js  
module.exports = {  
  module: {  
    rules: [  
      {  
        test: /\.css$/,  
        use: [  
          { loader: 'style-loader' },  
          {  
            loader: 'css-loader',  
            options: {  
              modules: true  
            }  
          },  
          { loader: 'sass-loader' }  
        ]  
      }  
    ]  
  }  
};  
```  
  
  
  
## 二、特性  
  
这里继续拿上述代码，来讲讲`loader`的特性  
  
从上述代码可以看到，在处理`css`模块的时候，`use`属性中配置了三个`loader`分别处理`css`文件  
  
因为`loader `支持链式调用，链中的每个` loader `会处理之前已处理过的资源，最终变为`js`代码。顺序为相反的顺序执行，即上述执行方式为`sass-loader`、`css-loader`、`style-loader`  
  
除此之外，`loader`的特性还有如下：  
  
- loader 可以是同步的，也可以是异步的  
- loader 运行在 Node.js 中，并且能够执行任何操作  
- 除了常见的通过 `package.json` 的 `main` 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 `loader` 字段直接引用一个模块  
- 插件(plugin)可以为 loader 带来更多特性  
- loader 能够产生额外的任意文件  
  
可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和更多其他特性  
  
  
  
  
  
## 三、常见的loader  
  
在页面开发过程中，我们经常性加载除了`js`文件以外的内容，这时候我们就需要配置响应的`loader`进行加载  
  
常见的`loader`如下：  
  
- style-loader: 将css添加到DOM的内联样式标签style里  
- css-loader :允许将css文件通过require的方式引入，并返回css代码  
- less-loader: 处理less  
- sass-loader: 处理sass  
- postcss-loader: 用postcss来处理CSS  
- autoprefixer-loader: 处理CSS3属性前缀，已被弃用，建议直接使用postcss  
- file-loader: 分发文件到output目录并返回相对路径  
- url-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url  
- html-minify-loader: 压缩HTML  
- babel-loader :用babel来转换ES6文件到ES  
  
  
  
下面给出一些常见的`loader`的使用：  
  
### css-loader  
  
分析 `css` 模块之间的关系，并合成⼀个 `css`  
  
```bash  
npm install --save-dev css-loader  
```  
  
```js  
rules: [  
  ...,  
 {  
  test: /\.css$/,  
    use: {  
      loader: "css-loader",  
      options: {  
     // 启用/禁用 url() 处理  
     url: true,  
     // 启用/禁用 @import 处理  
     import: true,  
        // 启用/禁用 Sourcemap  
        sourceMap: false  
      }  
    }  
 }  
]  
```  
  
如果只通过`css-loader`加载文件，这时候页面代码设置的样式并没有生效  
  
原因在于，`css-loader`只是负责将`.css`文件进行一个解析，而并不会将解析后的`css`插入到页面中  
  
如果我们希望再完成插入`style`的操作，那么我们还需要另外一个`loader`，就是`style-loader`  
  
  
  
### style-loader  
  
把 `css-loader` 生成的内容，用 `style` 标签挂载到页面的 `head` 中  
  
```bash  
npm install --save-dev style-loader  
```  
  
```js  
rules: [  
  ...,  
 {  
  test: /\.css$/,  
    use: ["style-loader", "css-loader"]  
 }  
]  
```  
  
同一个任务的 `loader` 可以同时挂载多个，处理顺序为：从右到左，从下往上  
  
  
  
  
  
### less-loader  
  
开发中，我们也常常会使用`less`、`sass`、`stylus`预处理器编写`css`样式，使开发效率提高，这里需要使用`less-loader`  
  
```cmd  
npm install less-loader -D  
```  
  
```js  
rules: [  
  ...,  
 {  
  test: /\.css$/,  
    use: ["style-loader", "css-loader","less-loader"]  
 }  
]  
```  
  
  
  
### raw-loader  
  
在 `webpack `中通过 `import `方式导入文件内容，该`loader `并不是内置的，所以首先要安装  
  
```bash  
npm install --save-dev raw-loader  
```  
  
然后在 webpack.config.js 中进行配置  
  
```javascript  
module.exports = {  ...,  module: {      rules: [      {        test: /\.(txt|md)$/,        use: 'raw-loader'     }    ] }}  
```  
  
  
  
### file-loader  
  
把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)  
  
```bash  
npm install --save-dev file-loader  
```  
  
```javascript  
rules: [  ..., {  test: /\.(png|jpe?g|gif)$/,    use: {      loader: "file-loader",      options: {        // placeholder 占位符 [name] 源资源模块的名称        // [ext] 源资源模块的后缀        name: "[name]_[hash].[ext]",        //打包后的存放位置        outputPath: "./images",        // 打包后文件的 url        publicPath: './images',      }    } }]  
```  
  
  
  
### url-loader  
  
可以处理理 `file-loader` 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 `base64`  格式的字符串，并打包到 `js` 中，对小体积的图片比较合适，大图片不合适。  
  
```bash  
npm install --save-dev url-loader  
```  
  
```javascript  
rules: [  ..., {  test: /\.(png|jpe?g|gif)$/,    use: {      loader: "url-loader",      options: {        // placeholder 占位符 [name] 源资源模块的名称        // [ext] 源资源模块的后缀        name: "[name]_[hash].[ext]",        //打包后的存放位置        outputPath: "./images"        // 打包后文件的 url        publicPath: './images',        // 小于 100 字节转成 base64 格式        limit: 100      }    } }]  
```  
  
  
# 说说webpack的构建流程?  
  
![](https://static.vue-js.com/96cf6840-a658-11eb-85f6-6fac77c0c9b3.png)  
  
## 一、运行流程  
  
`webpack` 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来  
  
在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条`webpack`机制中，去改变`webpack`的运作，使得整个系统扩展性良好  
  
从启动到结束会依次执行以下三大步骤：  
  
- 初始化流程：从配置文件和 `Shell` 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数  
- 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理  
- 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统  
  
 ![](https://static.vue-js.com/b566d400-a658-11eb-85f6-6fac77c0c9b3.png)  
  
  
### 初始化流程  
  
从配置文件和 `Shell` 语句中读取与合并参数，得出最终的参数  
  
配置文件默认下为`webpack.config.js`，也或者通过命令的形式指定配置文件，主要作用是用于激活`webpack`的加载项和插件  
  
关于文件配置内容分析，如下注释：  
  
```js  
var path = require('path');  
var node_modules = path.resolve(__dirname, 'node_modules');  
var pathToReact = path.resolve(node_modules, 'react/dist/react.min.js');  
  
module.exports = {  
  // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。  
  entry: './path/to/my/entry/file.js'，  
  // 文件路径指向(可加快打包过程)。  
  resolve: {  
    alias: {  
      'react': pathToReact  
    }  
  },  
  // 生成文件，是模块构建的终点，包括输出文件与输出路径。  
  output: {  
    path: path.resolve(__dirname, 'build'),  
    filename: '[name].js'  
  },  
  // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。  
  module: {  
    loaders: [  
      {  
        test: /\.js$/,  
        loader: 'babel',  
        query: {  
          presets: ['es2015', 'react']  
        }  
      }  
    ],  
    noParse: [pathToReact]  
  },  
  // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。  
  plugins: [  
    new webpack.HotModuleReplacementPlugin()  
  ]  
};  
```  
  
`webpack` 将 `webpack.config.js` 中的各个配置项拷贝到 `options` 对象中，并加载用户配置的 ` plugins`  
  
完成上述步骤之后，则开始初始化`Compiler`编译对象，该对象掌控者`webpack`声明周期，不执行具体的任务，只是进行一些调度工作  
  
```js  
class Compiler extends Tapable {  
    constructor(context) {  
        super();  
        this.hooks = {  
            beforeCompile: new AsyncSeriesHook(["params"]),  
            compile: new SyncHook(["params"]),  
            afterCompile: new AsyncSeriesHook(["compilation"]),  
            make: new AsyncParallelHook(["compilation"]),  
            entryOption: new SyncBailHook(["context", "entry"])  
            // 定义了很多不同类型的钩子  
        };  
        // ...  
    }  
}  
  
function webpack(options) {  
  var compiler = new Compiler();  
  ...// 检查options,若watch字段为true,则开启watch线程  
  return compiler;  
}  
...  
```  
  
`Compiler` 对象继承自 `Tapable`，初始化时定义了很多钩子函数  
  
  
  
### 编译构建流程  
  
根据配置中的 `entry` 找出所有的入口文件  
  
```js  
module.exports = {  
  entry: './src/file.js'  
}  
```  
  
初始化完成后会调用`Compiler`的`run`来真正启动`webpack`编译构建流程，主要流程如下：  
  
- `compile` 开始编译  
- `make` 从入口点分析模块及其依赖的模块，创建这些模块对象  
- `build-module` 构建模块  
- `seal` 封装构建结果  
- `emit` 把各个chunk输出到结果文件  
  
  
  
#### compile 编译  
  
执行了`run`方法后，首先会触发`compile`，主要是构建一个`Compilation`对象  
  
该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象  
  
  
  
#### make 编译模块  
  
当完成了上述的`compilation`对象后，就开始从`Entry`入口文件开始读取，主要执行`_addModuleChain()`函数，如下：  
  
```js  
_addModuleChain(context, dependency, onModule, callback) {  
   ...  
   // 根据依赖查找对应的工厂函数  
   const Dep = /** @type {DepConstructor} */ (dependency.constructor);  
   const moduleFactory = this.dependencyFactories.get(Dep);  
     
   // 调用工厂函数NormalModuleFactory的create来生成一个空的NormalModule对象  
   moduleFactory.create({  
       dependencies: [dependency]  
       ...  
   }, (err, module) => {  
       ...  
       const afterBuild = () => {  
        this.processModuleDependencies(module, err => {  
         if (err) return callback(err);  
         callback(null, module);  
           });  
    };  
         
       this.buildModule(module, false, null, null, err => {  
           ...  
           afterBuild();  
       })  
   })  
}  
```  
  
过程如下：  
  
`_addModuleChain`中接收参数`dependency`传入的入口依赖，使用对应的工厂函数`NormalModuleFactory.create`方法生成一个空的`module`对象  
  
回调中会把此`module`存入`compilation.modules`对象和`dependencies.module`对象中，由于是入口文件，也会存入`compilation.entries`中  
  
随后执行`buildModule`进入真正的构建模块`module`内容的过程  
  
  
  
#### build module 完成模块编译  
  
这里主要调用配置的`loaders`，将我们的模块转成标准的`JS`模块  
  
在用` Loader` 对一个模块转换完后，使用 `acorn` 解析转换后的内容，输出对应的抽象语法树（`AST`），以方便 `Webpack `后面对代码的分析  
  
从配置的入口模块开始，分析其 `AST`，当遇到` require `等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系  
  
  
  
### 输出流程  
  
#### seal 输出资源  
  
`seal`方法主要是要生成`chunks`，对`chunks`进行一系列的优化操作，并生成要输出的代码  
  
`webpack` 中的 `chunk` ，可以理解为配置在 `entry` 中的模块，或者是动态引入的模块  
  
根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `Chunk`，再把每个 `Chunk` 转换成一个单独的文件加入到输出列表  
  
  
  
#### emit 输出完成  
  
在确定好输出内容后，根据配置确定输出的路径和文件名  
  
```js  
output: {  
    path: path.resolve(__dirname, 'build'),  
        filename: '[name].js'  
}  
```  
  
在 `Compiler` 开始生成文件前，钩子 `emit` 会被执行，这是我们修改最终文件的最后一个机会  
  
从而`webpack`整个打包过程则结束了  
  
  
  
### 小结  
  
 ![](https://static.vue-js.com/d77fc560-a658-11eb-85f6-6fac77c0c9b3.png)  
  
  
  
  
# 说说你对webpack的理解？解决了什么问题？  
![](https://static.vue-js.com/898ed570-a578-11eb-85f6-6fac77c0c9b3.png)  
  
## 一、背景  
  
`Webpack` 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源  
  
#### 模块化  
  
最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的` JS` 文件中  
  
约定每个文件是一个独立的模块，然后再将这些`js`文件引入到页面，一个`script`标签对应一个模块，然后调用模块化的成员  
  
```html  
<script src="module-a.js"></script>  
<script src="module-b.js"></script>  
```  
  
但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题  
  
项目一旦变大，上述问题会尤其明显  
  
随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中  
  
```js  
window.moduleA = {  
  method1: function () {  
    console.log('moduleA#method1')  
  }  
}  
```  
  
这种方式也并没有解决第一种方式的依赖等问题  
  
再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下  
  
```js  
// module-a.js  
(function ($) {  
  var name = 'module-a'  
  
  function method1 () {  
    console.log(name + '#method1')  
    $('body').animate({ margin: '200px' })  
  }  
      
  window.moduleA = {  
    method1: method1  
  }  
})(jQuery)  
```  
  
上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过`script`标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久维护起来也十分的麻烦  
  
理想的解决方式是，在页面中引入一个` JS `入口文件，其余用到的模块可以通过代码控制，按需加载进来  
  
除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是`CommonJS `、`ES Modules`  
  
  
## 二、问题  
  
从后端渲染的`JSP`、`PHP`，到前端原生`JavaScript`，再到`jQuery`开发，再到目前的三大框架`Vue`、`React`、`Angular`  
  
开发方式，也从`javascript`到后面的`es5`、`es6、7、8、9、10`，再到`typescript`，包括编写`CSS`的预处理器`less`、`scss`等  
  
现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：  
  
- 需要通过模块化的方式来开发  
- 使用一些高级的特性来加快我们的开发效率或者安全性，比如通过ES6+、TypeScript开发脚本逻辑，通过sass、less等方式来编写css样式代码  
- 监听文件的变化来并且反映到浏览器上，提高开发的效率  
- JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题  
- 开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化  
  
而`webpack`恰巧可以解决以上问题  
  
  
## 三、是什么  
  
`webpack` 是一个用于现代` JavaScript `应用程序的静态模块打包工具  
  
- 静态模块  
  
这里的静态模块指的是开发阶段，可以被 `webpack` 直接引用的资源（可以直接被获取打包进`bundle.js`的资源）  
  
当 `webpack `处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限`js`文件），并生成一个或多个 `bundle`  
  
 ![](https://static.vue-js.com/9ce194a0-a578-11eb-85f6-6fac77c0c9b3.png)  
  
#### `webpack`的能力：  
  
**编译代码能力**，提高效率，解决浏览器兼容问题  
![](https://static.vue-js.com/c5c2d360-a592-11eb-ab90-d9ae814b240d.png)  
**模块整合能力**，提高性能，可维护性，解决浏览器频繁请求文件的问题  
![](https://static.vue-js.com/d306d260-a592-11eb-ab90-d9ae814b240d.png)  
**万物皆可模块能力**，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制  
![](https://static.vue-js.com/e3c5a040-a592-11eb-ab90-d9ae814b240d.png)  
  
# Babel的原理是什么  
<p style="text-align:start;text-indent:2em;">babel 的转译过程分为三个阶段，这三步具体是：</p><ul><li>解析 Parse: 将代码解析生成抽象语法树( 即AST )，即词法分析与语法分析的过程</li><li>转换 Transform: 对于 AST 进行变换一系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添加、更新及移除等操作</li><li>生成 Generate: 将变换后的 AST 再转换为 JS 代码, 使用到的模块是 babel-generator</li></ul>  
# webpack的热更新是如何做到的？说明其原理  
<p>webpack的热更新又称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p><br/> 首先要知道server端和client端都做了处理工作<br/> </p><ol><li>第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li><li>第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</li><li>第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</li><li>第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</li><li>webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</li><li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li><li>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li><li>最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</li></ol><p> </p>  
# 如何提高webpack的打包速度  
<ul><li>happypack: 利用进程并行编译loader,利用缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项目,类似的替代者是<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fthread-loader" target="_blank">thread-loader</a> </li><li> <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwebpack.docschina.org%2Fconfiguration%2Fexternals%2F" target="_blank">外部扩展(externals)</a>: 将不怎么需要更新的第三方库脱离webpack打包，不被打入bundle中，从而减少打包时间,比如jQuery用script标签引入</li><li>dll: 采用webpack的 DllPlugin 和 DllReferencePlugin 引入dll，让一些基本不会改动的代码先打包成静态资源,避免反复编译浪费时间</li><li>利用缓存: <code>webpack.cache</code>、babel-loader.cacheDirectory、<code>HappyPack.cache</code>都可以利用缓存提高rebuild效率</li><li>缩小文件搜索范围: 比如babel-loader插件,如果你的文件仅存在于src中,那么可以<code>include: path.resolve(__dirname, &#x27;src&#x27;)</code>,当然绝大多数情况下这种操作的提升有限,除非不小心build了node_modules文件<br/></li></ul>  
# 如何用webpack来优化前端性能  
<p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。<br/> </p><ul><li>压缩代码:删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的<code>UglifyJsPlugin</code>和<code>ParallelUglifyPlugin</code>来压缩JS文件， 利用<code>cssnano</code>（css-loader?minimize）来压缩css</li><li> </li><li>利用CDN加速: 在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于<code>output</code>参数和各loader的<code>publicPath</code>参数来修改资源路径</li><li>Tree Shaking: 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数<code>--optimize-minimize</code>来实现</li><li>Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利用浏览器缓存</li><li>提取公共第三方库:  SplitChunksPlugin插件来进行公共模块抽取,利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码</li></ul><p></p>  
# webpack的构建流程是什么  
<p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：<br/> </p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p> </p>  
# webpack的Loader和Plugin的不同  
<p><strong>不同的作用:</strong><br/> </p><ul><li> <strong>Loader</strong>直译为&quot;加载器&quot;。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到<code>loader</code>。 所以Loader的作用是让webpack拥有了加载和解析<em>非JavaScript文件</em>的能力。</li><li> <strong>Plugin</strong>直译为&quot;插件&quot;。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p> <strong>不同的用法:</strong><br/> </p><ul><li> <strong>Loader</strong>在<code>module.rules</code>中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个<code>Object</code>，里面描述了对于什么类型的文件（<code>test</code>），使用什么加载(<code>loader</code>)和使用的参数（<code>options</code>）</li><li> <strong>Plugin</strong>在<code>plugins</code>中单独配置。 类型为数组，每一项是一个<code>plugin</code>的实例，参数都通过构造函数传入。</li></ul><p><br/></p>  
# webpack有哪些常见的Plugin  
<ul><li> define-plugin：定义环境变量</li><li> html-webpack-plugin：简化html文件创建</li><li> uglifyjs-webpack-plugin：通过<code>UglifyES</code>压缩<code>ES6</code>代码</li><li> webpack-parallel-uglify-plugin: 多核压缩,提高压缩速度</li><li> webpack-bundle-analyzer: 可视化webpack输出文件的体积</li><li> mini-css-extract-plugin: CSS提取到单独的文件中,支持按需加载<br/><br/></li></ul>  
# webpack、rollup、parcel优劣  
<ul><li>webpack适用于大型复杂的前端站点构建: webpack有强大的loader和插件生态,打包后的文件实际上就是一个立即执行函数，这个立即执行函数接收一个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。立即执行函数内部则处理模块之间的引用，执行模块等,这种情况更适合文件依赖复杂的应用开发.</li><li> rollup适用于基础库的打包，如vue、d3等: Rollup 就是将各个模块打包进一个文件中，并且通过 Tree-shaking 来删除无用的代码,可以最大程度上降低代码体积,但是rollup没有webpack如此多的的如代码分割、按需加载等高级功能，其更聚焦于库的打包，因此更适合库的开发.</li><li>parcel适用于简单的实验性项目: 他可以满足低门槛的快速看到效果,但是生态差、报错信息不够全面都是他的硬伤，除了一些玩具项目或者实验项目不建议使用<br/><br/></li></ul>  
# Webpack中 loader的作用是什么，以及常用loader有哪些  
<p><strong>loader作用</strong>：</p><p style="text-align:start;text-indent:2em;"></p><p style="text-align:start;text-indent:2em;">（1）实现对不同格式文件的处理，比如将Scss转换为CSS，或将 TypeScript转化为Javascript。</p><p style="text-align:start;text-indent:2em;">（2）可以编译文件，从而使其能够添加到依赖关系中。loader是 WebPack最重要的部分之一。通过使用不同的 loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理。loader需要在 webpack.config.js里单独用 module进行配置。</p><p></p><p></p><p><strong>常用的 loader如下</strong>：</p><p></p><p>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br/> url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br/> source-map-loader：加载额外的 Source Map 文件，以方便断点调试<br/> image-loader：加载并且压缩图片文件<br/> babel-loader：把 ES6 转换成 ES5<br/> css-loader：加载 CSS，支持模块化、压缩、文件导入等特性<br/> style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br/> eslint-loader：通过 ESLint 检查 JavaScript 代码<br/><br/></p>  
# 谈谈你对 Webpack的认识  
<p style="text-align:start;text-indent:2em;">WebPack是一个模块打包工具，可以使用 WebPack管理模块依赖，并编译输岀模块所需的静态文件。它能够很好地管理与打包Web开发中所用到的HTML、 JavaScript 、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源， WebPack有对应的模块加载器。Web Pack模块打包器会分析模块间的依赖关系，最后生成优化且合并后的静态资源。</p><p style="text-align:start;text-indent:2em;">WebPack的两大特色如下。</p><p style="text-align:start;text-indent:2em;">（1）代码切割（ code splitting）</p><p style="text-align:start;text-indent:2em;">（2） loader可以处理各种类型的静态文件，并且支持串行操作WebPack以 CommonJS规范来书写代码，但对 AMD/CMD的支持也很全面，方便对项目进行代码迁移。</p><p style="text-align:start;text-indent:2em;">WebPack具有 require.js和 browserify的功能，但也有很多自己的新特性，</p><p style="text-align:start;text-indent:2em;">（1）对 CommonJS、AMD、ES6的语法实现了兼容。</p><p style="text-align:start;text-indent:2em;">（2）对 JavaScript、CSS、图片等资源文件都支持打包</p><p style="text-align:start;text-indent:2em;">（3）串联式模块加载器和插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、 EMAScript 6的支持</p><p style="text-align:start;text-indent:2em;">（4）有独立的配置文件 webpack.config. js。</p><p style="text-align:start;text-indent:2em;">（5）可以将代码切割成不同的块，实现按需加载，缩短了初始化时间。</p><p style="text-align:start;text-indent:2em;">（6）支持 SourceUrls和 SourceMaps，易于调试。</p><p style="text-align:start;text-indent:2em;">（7）具有强大的 Plugin接口，大多是内部插件，使用起来比较灵活</p><p style="text-align:start;text-indent:2em;">（8）使用异步I/O，并具有多级缓存，这使得 WebPack速度很快且在增量编译上更加快。</p>  
