小红喜欢吃多彩糖葫芦，多彩糖葫芦上的每一个糖葫芦都有一种颜色。但小红有非常严重的强迫症，她绝对不会连续吃两个相同颜色的糖葫芦。一串糖葫芦只能从上往下吃，一旦小红发现下一颗糖葫芦和她刚吃过的糖葫芦颜色相同时，小红就会把整串多彩糖葫芦丢掉。
小红想知道她吃一串多彩糖葫芦时可以吃到几颗糖葫芦。
对输入的要求是：一个字符串，按从前往后的顺序表示多彩糖葫芦串上从上到下每一颗糖葫芦的颜色。
对输出的要求是：一个整数表示答案。

小红准备买药治病。已知共有n种症状和m种药，第i种药可以治疗一些症状，但可能会导致一些副作用，添加一些新的症状。小红依次服用了一些药，请你告诉小红，当她每次服用一副药时，当前还有多少症状?
对输入的要求是：
第一行输入一个正整数n，代表症状的数量；
第二行输入一个长度为n的01串，第i位是'1'代表小红目前有第i个症状，第i位是'0'代表没有该症状；
第三行输入一个正整数m，代表药的数量接下来的2*m行，每2行描述一副药：第一行输入一个长度为n的01串，代表该药能治疗的症状。"1'代表可以治疗，"0'代表不能治疗，第二行输入一个长度为n的01串，代表该药会产生的副作用。"1'代表会产生该症状，"0'代表不会产生；
2*m行后，接下来的一行，输入一个正整数9，代表小红服用的药数量；
接下来的9行，每行输入一个正整数u，代表小红服用了第u副药。
对输出的要求是：输出q行，每行输出一个正整数，代表当前小红服用药后，身体有多少症状。

有一个n行m列的棋盘，有一些格子是障碍物不能通过。小红控制一个皇后在从左上角出发，每次移动她可以控制皇后进行以下三种方式中的一种:1.向右移动若干个格子。2.向下移动若干个格子3，向右下移动若千个格子。
用数学语言描述，当前的坐标在(x,y)时，每次移动可以到(x+k,y)或(x,y+k)或(x+k,y+k)，其中k为任意正整数。移动的前提是，路径上没有障碍物。小红想知道，皇后从左上角移动到右下角，最少要移动多少步?
对输入的要求是：
第一行输入两个正整数n和m，代表行数和列数；
接下来的n行，每行输入一个长度m的字符串，用来表示棋盘，其中‘.‘代表可以通过的位置，‘*’代表障碍物。保证左上角和右下角都不是障碍物。
对输出的要求是：
如果无法到达，请输出-1，否则输出一个整数，代表最少的移动次数。


整理vue中8种常规的通信方案：
通过 props 传递
适用场景：父组件传递数据给子组件
子组件设置props属性，定义接收父组件传递过来的参数
父组件在使用子组件标签中通过字面量来传递值

通过 $emit 触发自定义事件
适用场景：子组件传递数据给父组件
子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值
父组件绑定监听器获取到子组件传递过来的参数

使用 ref
父组件在使用子组件的时候设置ref
父组件通过设置子组件ref来获取数据

EventBus
使用场景：兄弟组件传值
创建一个中央事件总线EventBus
兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值
另一个兄弟组件通过$on监听自定义事件

$parent 或$root
通过共同祖辈$parent或者$root搭建通信侨联
兄弟组件
this.$parent.$on('add',this.add)
另一个兄弟组件
this.$parent.$emit('add')

attrs 与 listeners
适用场景：祖先传递数据给子孙
设置批量向下传属性$attrs和 $listeners
包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。
可以通过 v-bind="$attrs" 传⼊内部组件

Provide 与 Inject
在祖先组件定义provide属性，返回传递的值
在后代组件通过inject接收组件传递过来的值

Vuex
Vuex作用相当于一个用来存储共享变量的容器

js 中的异步机制可以分为以下几种：

第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。

第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。

第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。

第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。

1.
function getRandomArr(len = 5, min = 2, max = 32) {
    const result = [];
    
    // 递归基准情况：当结果数组长度达到指定长度时，终止递归
    if (result.length === len) {
      return result;
    }
    
    // 生成随机数
    const randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;
    
    // 判断随机数是否已存在于结果数组中
    if (!result.includes(randomNumber)) {
      result.push(randomNumber);
    }
    
    // 递归调用
    return getRandomArr(len, min, max);
  }
  
  

2.
function findMaxBeautyValue(arr) {
  const len = arr.length;
  let maxBeauty = -Infinity;
  for (let now = 0; now < len; now++) {
    for (let next = now + 1; next < len; next++) {
      maxBeauty = Math.max(maxBeauty, arr[now] * arr[next]);
    }
  }
  return maxBeauty;
}

3.
function curry(fn, ...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    }
    return function (...rest) {
      return curry(fn, ...args, ...rest);
    };
}

4.
  computed: {
    arrowStyle() {
      const angleRad = (this.angle / 180) * Math.PI; // 将角度转换为弧度
      const rotation = `rotate(${angleRad}rad)`;
      return {
        transform: rotation,
      };
    },
  },
